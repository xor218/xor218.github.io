---
layout: post
author: "大西瓜"
title: "unix高级环境编程笔记"
date:   2024-05-05 16:00:13 +0800
categories: [update,LinuxBase] 
---
##  UC的起步

![](allPic/Macdo2023-04-04 09.17.28.jpg)



![](allPic/Macdo2023-04-04 09.49.58.jpg)

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-04 09.54.34.jpg)

unix高级编程

### 程序的编译过程

```bash
gcc -E main.c -o main.i  #预处理
```

```bash
gcc -S hello.i -o hello.s  # 编译 生成汇编语言 语法错误检查
```

```
gcc -c hello.s -o hello.o  #
```

```
gcc hello.o       #链接
```



### 预处理指令

 带#的预处理指令

宏定义

条件编译

文件的包含



## 多模块开发

#### 把大型项目分割为多个模块

```yaml
头文件应该包含的内容
  头文件卫士  #ifndef 避免文件的重复包含
  类型的定义	 #结构的定义  typedef
  文件的包含		#头文件的包含 
  宏定义			#
  条件编译		#ifdnef
  函数声明		# 类似于
  变量的声明  #变量的声明和定义是两个概念 声明不分配空间(作用于的扩充) 变量的定义是需要分配空间的
```



单个模块检查自己,会生成.o文件。机器码

```bash
gcc -c add.c
```

```bash
file main.o #可以重定位的
main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
```

```bash
file a.out #可以执行的
ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=25c6dc8b5f98f80410210f35e84c5d56bd2d4a0b, for GNU/Linux 3.2.0, not stripped
```

#### nm 命令查看二进制文件的符号表

符号表: `函数的名字`,` 全局变量的名字`,` 静态变量的名字`

- T：该符号为函数符号，即可执行代码。在代码段；
- t：该符号为本地函数符号，即仅在当前文件中可见的函数。
- D：该符号为数据符号，即可读写数据。
- d：该符号为本地数据符号，即仅在当前文件中可见的数据。
- B：该符号为未初始化数据符号，即可读写的数据段的一部分。
- b：该符号为本地未初始化数据符号，即仅在当前文件中可见的未初始化数据。
- U：该符号为未定义符号，即需要在链接时从其他模块中解析得到的符号。
- S ：符号表示被标记为静态的符号
- C ：符号表示被标记为常规（全局）的符号
- `w`：该符号是一个全局弱符号。
- `W`：该符号是一个弱符号，但是该符号定义在另一个可重定位文件中。
- `v`：该符号是一个局部弱符号，即只在文件内部可见

`T代表有定义`

```bash
loc_Ubuntu:nm add.o		T 代表有定义
0000000000000000 T t_add
0000000000000018 T t_sub
```

`U代表为定义的`

```bash
loc_Ubuntu:nm main.o
0000000000000000 T main
                 U printf
                 U t_add
                 U t_mul
```

``

U 符号没有地址 说明在链接过程中需要从其他对象文件中解析

```bash
#: gcc -c main.c -o main.o
#: nm main.o
                 U _arr     		//没有地址 说明需要链接的时候需要从其他文件中或者库文件中解析                     
0000000000000000 T _func2      
0000000000000050 T _main
                 U _printf                       
                 U _showarr_2o
00000000000000b0 s l_.str
0000000000000000 t ltmp0
00000000000000b0 s ltmp1  
00000000000000c0 s ltmp2
#: 
```



```bash
loc_Ubuntu:nm a.out 
000000000000038c r __abi_tag
0000000000004010 B __bss_start
0000000000004010 b completed.0
                 w __cxa_finalize@GLIBC_2.2.5
0000000000004000 D __data_start
0000000000004000 W data_start
0000000000001090 t deregister_tm_clones
0000000000001100 t __do_global_dtors_aux
0000000000003dc0 d __do_global_dtors_aux_fini_array_entry
0000000000004008 D __dso_handle
0000000000003dc8 d _DYNAMIC
0000000000004010 D _edata
0000000000004018 B _end
0000000000001220 T _fini
0000000000001140 t frame_dummy
0000000000003db8 d __frame_dummy_init_array_entry
00000000000021a0 r __FRAME_END__
0000000000003fb8 d _GLOBAL_OFFSET_TABLE_
                 w __gmon_start__
0000000000002024 r __GNU_EH_FRAME_HDR
0000000000001000 T _init
0000000000002000 R _IO_stdin_used
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 U __libc_start_main@GLIBC_2.34
0000000000001177 T main
                 U printf@GLIBC_2.2.5
00000000000010c0 t register_tm_clones
0000000000001060 T _start
0000000000001149 T t_add
0000000000001209 T t_div
0000000000004010 D __TMC_END__
00000000000011f2 T t_mul
0000000000001161 T t_sub
```

测试用

```c
//file delete.c
int a=4;
static float b=5.;

int fuck(){
    static int temp=10;
    return 1;
}

static int sayhello(){
    return 3;
}

//loc_Ubuntu:	gcc -c delete.c 
//loc_Ubuntu:	nm delete.o

/*
0000000000000000 D a					//该符号为数据符号，即可读写数据。
0000000000000004 d b					//d：该符号为本地数据符号，即仅在当前文件中可见的数据。
0000000000000000 T fuck				//T：该符号为函数符号，即可执行代码。
0000000000000008 d temp.0	  	//函数内的静态变量
000000000000000f t sayhello	 	//t：该符号为本地函数符号，即仅在当前文件中可见的函数。
*/

静态链接

```



#### include <> 和 ""区别

在进行预处理的时候

`gcc -E main.c -o main.i -v`  要预处理的时候 参数v可以显示头文件和库文件寻找的过程



#### GDB调试器的使用

在gcc 编译的时候加上参数-g

`gcc main.c add.c sub.c -g` 可以生成带有调试信息的生成文件

`ggdb  a.out`

```bash
loc_Ubuntu:file a.out 
a.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=eabd4e116754f8650739045c5f27a9340be4cc05, for GNU/Linux 3.2.0, with debug_info, not stripped 

//with debug_info

```

```
l 打印代码
2 break 行号码 或者函数
3 run 运行代码
4 n  xia一步
5 set x= 6 设置变量
6 s 继续执行
7 p 变量  print 变量
8 退出



```



`GDB是一款强大的命令行调试工具，其命令众多，以下是一些常用的GDB命令：`

1. 启动程序：`gdb <executable>`或`gdb --args <executable> <arguments>`
2. 设置断点：`break`或`b`命令，例如`break function_name`或`b *address`
3. 查看断点：`info breakpoints`命令
4. 删除断点：`delete`或`d`命令，例如`delete breakpoint_number`或`d *address`
5. 单步执行：`next`或`n`命令
6. 逐过程执行：`step`或`s`命令     进入函数里面
7. 继续执行：`continue`或`c`命令
8. 查看程序状态：`info program`命令
9. 查看栈帧信息：`info frame`命令
10. 查看局部变量值：`print`或`p`命令，例如`print var_name`
11. 查看寄存器值：`info registers`命令
12. 修改变量值：`set`命令，例如`set var_name = new_value`
13. 查看内存内容：`x`命令，例如`x/nfu address`，其中n为显示的字节数，f为显示格式，u为单元长度（字节、字或双字）
14. 查看源代码：`list`或`l`命令，例如`list line_number`或`l function_name`
15. 运行时调试：`attach`命令，例如`attach <pid>`
16. 查看线程状态：`info threads`命令
17. 切换线程：`thread`或`t`命令，例如`thread thread_number`或`t thread_number`
18. 查看帮助：`help`或`h`命令，例如`help break`或`h break`



#### 环境变量

环境变量 可以被子进程继承的变量

`bash进程启动后，会自动执行脚本文件  ~/.bashrc`

自定义变量

1. env查看bash进程的环境变量

2. $name 可以获取环境变量的值

3. name=value 如果name是环境变量，将环境变量的值更改为value，如果name不是环境变量，为bash进程添加自定义变量
4. export name 将name输出为环境变量
5. unset name 删除变量name

`如果 env ｜grep 变量`找不到值，`echo $变量`那就是自定义变量

`set`命令查看所有的自定义变量和环境变量

#### pstree 查看进程

`pstree -p` 查看带进程数

`pstree -p $$` 查看当前的进程ID



## 库文件

**库函数的命名规则**

​	动态库的命名规则 `lib库名.so`

​	静态库的命名规则 `lib库名.a`

### 静态库的制作和使用 

​	**动态库的作用:只把代码里面需要的函数或者符号包含到可执行文件当中,但是每个进程都会复制一份**

​	**命令 ar**

​	将所有要加入库的源文件编译为目标文件

```bash
gcc -c *.c   							# 所有的文件会生成.o文件 二进制可以重定位的
```

​	将第一步生成的所有目标文件打包成静态库文件

```bash
ar -r lib+库名.a sub.o add.o   # 用 sub.o add.o  生成 lib库名.a 文件

ar -t lib库名.a  //查看库中包含什么二进制文件
```

​	使用静态哭文件链接生成可执行文件　

```bash
gcc -c main.c -o main.o

gcc main.o -L. -l库名  #告诉gcc 去当前文件夹下面找 lib库名.c 文件  参数-I 头文件路径

#也可以
gcc main.c -L. -l库名  #告诉gcc 去当前文件夹下面找 lib库名.c 文件 
```

<img src="allPic/Macdo2023-04-04 13.37.11.jpg" style="zoom:50%;" />

```bash
#:ls -l *.out
-rwxrwxr-x 1 min122218 min122218 16048  4月  4 13:51 a2.out			//静态库会比直接生成的小 大小是16048 字节
-rwxrwxr-x 1 min122218 min122218 16144  4月  4 13:44 a.out				//不要动态库 或者直接编译的会比较大
-rwxrwxr-x 1 min122218 min122218 15992  4月  4 14:34 a.out					//动态库的克制习惯文件 ，更小了
```



### 动态库的制作和使用 



​	将所有要加入库的源文件编译为目标文件，与位置无关的目标文件 

```bash
//与位置无关的目标文件 添加参数 -fPIC 也就是编译成动态库的时候要加参数 -fPIC
gcc -c -fPIC *.c  				
```

​	将第一步生成的目标文件打包成动态库文件中

```
gcc -shared -o lib库名.so  *.o  
```

​	使用动态连接库生成可执行文件

```bash
gcc -c main.c -o main.o		
gcc main.c -o a.out

./a.out 会找不到自己编译的动态库
可以用ldd 命令查看依赖的库
ldd a.out 
        linux-vdso.so.1 (0x00007ffd71fe3000)
        libmymath.so => not found   #没找到
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f056ec00000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f056eea5000)
        
解决的办法 LD_LIBRART_PATH 环境变量加入自己制作库文件的路径
连接器默认的路径是 /lib 和 /usr/lib 
export LD_LIBRART_PATH=$LD_LIBRART_PATH:your_path
echo 	$LD_LIBRARY_PATH

或者把自己做的动态库移动 LD_LIBRARY_PATH里面所在的路径里面

```

​		

**ldd命令可以查看依赖的库 只能查看动态库  **

**如果程序依赖的是静态库，可以使用 `nm` 命令查看静态库中的符号。如果程序链接的是静态库，可以使用 `objdump` 命令查看可执行文件中的符号**



```
利用动态库编译的时候需要指定了什么库 
一半用到了 /lib/libmath.so 
要在编译的时候 指定使用了math

gcc main.c -lmath 	# 系统指定了一些动态库查找的路径 编译的时候就不用指定了\


0000000000001157 T add
0000000000004028 b completed.0
                 w __cxa_finalize@GLIBC_2.2.5
0000000000001060 t deregister_tm_clones
00000000000010d0 t __do_global_dtors_aux
0000000000003e18 d __do_global_dtors_aux_fini_array_entry
0000000000004020 d __dso_handle
0000000000003e20 d _DYNAMIC
0000000000001218 t _fini
0000000000001110 t frame_dummy
0000000000003e10 d __frame_dummy_init_array_entry
00000000000021e0 r __FRAME_END__
0000000000004000 d _GLOBAL_OFFSET_TABLE_
                 w __gmon_start__
000000000000205c r __GNU_EH_FRAME_HDR
0000000000001000 t _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
00000000000011d6 T minruiadd
00000000000011b7 T minruisayname
0000000000001198 T minruishowpasswd
                 U printf@GLIBC_2.2.5
0000000000001090 t register_tm_clones
0000000000001138 T sayname
0000000000001119 T showpasswd
0000000000004028 d __TMC_END__


libfamily.so

```





### 不用库 动态库 静态库的优缺点

`不用库`:	会吧所有需要的函数符号全部包含在可执行文件中

`静态库`：只包含使用的函数或者符号，被所有程序动态链接。

`动态库`:	不包含使用的函数和符号,在内存中只有一个备份，被所有进程共享节约内存空间





## 动态加载

<img src="/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-05 23.17.08.jpg" style="zoom:50%;" />

`自动加载`：

​		

`动态加载`:

​	动态连接器的API都需要使用到dl动态库文件，所以链接的时候要用`-ldl` 

​	成功返回函数的指针，失败返回null

### 四个函数

```c
动态加载 
#include <difcn.h>
  void *dlopen(const char *filename,int flags);
功能:把动态库加载入到内存
  参数
  filename:共享库的路径，如果只给文件的名字，会按照动态连接器的搜索路径找到动态库文件
  LD_LIBRARY_PATH 指定的路径或者默认路径下面找
  flags:
			加载方式，可以取一下值
      RTLD_LAZY -延迟加载，使用使用共享库中的符号才加载
      RTLD_NOW -立即加载，函数返回的时候，已经加载到内存了
        
```



```c
#include <difcn.h>
  int dlclose(void *handle);  //关闭动态库加载的函数，只是计数器减1 
	参数：
    	动态库加载到内存的地址 dlopen()的返回值
  成功返回0
    失败返回非0； 可以用dlerror 诊断错误
```

​	

```c
 #include <dlfcn.h>

char *dlerror(void);  //返回最近错误的原因

 Link with -ldl.
```



```c
#include <dlfcn.h>

void *dlsym(void *handle, const char *symbol); //从动态库里面找出来函数

应该提前定义一个 指针类型 
  typedef int (*pfunc)(int,int); pfunc 为接受两个int 类型 并且返回 一个int 的函数指针
  pfunc func = (pfunc ) dlsym(handle,"库里面的函数")
```



###  调用操作系统提供的库的示范代码 

```c
示范代码 已经讲t_add，t_sub，t_mul，t_div做成动态库房到 LD_LIBRARY_PATH中

/**
 *          编译的时候 gcc dynamic.c -ldl
 *          ./a.out lib动态库.so  会从LD_LIBRARY_PATH 里面找
 *          用nm 和 ldd 命令都看不到 加载的库的符号 或者 动态库名称 
 *          ./a.out 依赖的是libdl.so.2
 *          #include "p_math.h"  //不需要使用头文件啊
*/



#include <dlfcn.h>   //动态加载所用到的库
#include <stdio.h>

//TODO:: 这句挺重要的 定义一个函数指针的类型，只是指针的类型，不是具体的指针
typedef int(* g_fun)(int ,int);   //定义一个全局的函数指针类型，不是具体的指针哈，只是类型 类似于 int *

int main(int argc,char *argv[]){

    if(!argv[1]){       //需要判断一下参数在不在 要不然返回的是 main函数，不回报错啥的
        printf("Usage: EROR\n");
        printf("[1]faild reason:%s\n",dlerror());
        return -1;
    }

void *handle=dlopen(argv[1], RTLD_NOW);
    if(handle == NULL){
        printf("loading failure...\n");
        printf("[1]faild reason:%s\n",dlerror());   //dlerror()  函数打印错误原因
        return -1;                                  //[1]faild reason:/lib/libmymath.so1: cannot open shared 		object file: No such file or directory
    }else{
        printf("loading success...\n");
    }

    //使用函数
    void * func =dlsym(handle, "t_mul");    //从句柄中找需要的符号（函数）字符串
    
    if(func == NULL){
        printf("dlsym Error:%s\n",dlerror());
        return -1;
    }

    g_fun fn= (g_fun)func;  //转换  void * 类型的指针 转换成需要的函数指针 

    printf("fn(5,8)=%d\n\n",fn(5,8));



    dlclose(handle);

    return 0;
}

```



## 错误处理

### error 错误的代码编号

```c
代码运行错误的时候，会有一个宏 errno 

需要包含头文件 <error.h> 

errno - number of last error,最后一次错误的代码 
```



### strerror 打印错误编号

```c
 #include <string.h>
 char *strerror(int errnum);
返回string 的指针 错误的原因
  
```



### perror 显示最后一次函数调用的信息

```c
 #include <stdio.h>

 void perror(const char *s);



#include <stdio.h>
int main(){
  	FILE *fp=fopen("filename","r");
  	if(fp == NULL){
      perror("fopen");  //参数为使用的函数名称 
      										//可能出现的错误 fopen: Bad address
      										//fopen: No such file or directory
      return -1;
    }
	
  	
    return 0;
}

ubantu: ./a.out 
helo,kitty: Success
```



### perror 封装成宏

```c
如果函数出错，就返回-1 退出
  可以移动到系统指定的系统库下面 /usr/include 

  //filename :t_stdio.h
#ifndef T_STDIO_H
#define T_STDIO_H

#include <stdio.h>
#define E_MSG(MESSAGE,NUM) do{perror(MESSAGE);return (NUM);}while(0)

#endif
```







## 内存管理

操作系统的MMU将内存的物理地址 映射成 虚拟地址 

程序员看到的内存地址都是操作的虚拟地址，包括操作系统自己操作的也是虚拟地址



`MMU是什么`

```c
MMU是Memory Management Unit的缩写，即内存管理单元。MMU是计算机系统中的一个硬件模块，主要功能是负责虚拟内存和物理内存之间的映射和管理。

在现代操作系统中，每个进程都会拥有自己独立的地址空间，这些地址空间中的地址是虚拟地址。为了方便管理和保护，操作系统将虚拟地址映射到物理地址上。这个过程需要通过MMU来完成。

MMU的主要工作包括：
虚拟地址转换：将进程中产生的虚拟地址转换为物理地址。
地址保护：根据进程的访问权限，控制进程对内存的访问。
虚拟内存管理：将虚拟地址和物理地址进行映射，支持页面换入和换出，提高内存利用率和效率。
高速缓存管理：管理CPU与内存之间的高速缓存，提高CPU访问内存的速度。
  
通过MMU的管理，操作系统可以为每个进程提供独立的地址空间，保护进程间的内存不互相干扰。同时，MMU还可以通过虚拟内存技术，允许进程使用比实际物理内存更大的内存空间，提高内存的利用率。
```

`实时模式`

​	直接访问的是内存的物理地址

`保护模式`

1. 逻辑地址

2. 虚拟地址

3. 线性地址

4. 物理地址

5. ```
   程序员看到的是虚拟地址，由逻辑地址推导出来的
   逻辑地址地址分为两部分 段选择 和 偏移量  
   程序员通常只需要指明段内的偏移量，分段管理机构 会把这个逻辑地址转换为线性地址
   如果没有分页机制 此时的线性地址就是最后的主存物理地址
   如果机器还有分页设备的话，分页机构把这个线性地址转换为最终的真实物理地址
   ```



### 虚拟地址和物理地址的说明	

```
C语言中看到的地址通常是虚拟地址，而不是物理内存的真实地址。在现代操作系统中，虚拟内存是由操作系统和硬件（包括CPU和MMU等）共同管理的。每个进程都有自己的虚拟地址空间，其中的地址与物理内存中的地址并不直接对应，而是通过地址映射机制进行映射。

具体来说，当程序访问某个虚拟地址时，会先通过MMU进行地址转换，将虚拟地址映射到物理地址。这个过程是由硬件自动完成的，程序员通常无需关心。因此，程序中看到的地址都是虚拟地址，而不是物理地址。

如果需要将物理地址转换为程序员看到的虚拟地址，可以使用操作系统提供的调试工具（如GDB），通过查看进程的内存映射关系来确定虚拟地址。例如，可以使用/proc文件系统中的/proc/<PID>/maps文件来查看进程的内存映射关系。在该文件中，可以找到进程的虚拟地址范围和物理地址范围的对应关系，从而确定虚拟地址。
```



### 如何查看进程使用的内存

`/proc/$$/maps` $$为进程的id

```c
start_address-end_address  permissions  offset  device  inode  pathname
段地址 	权限		偏移量		映射文件的设备		节点		路径

 
----------------------------------------------------------------------------
55e417bf8000-55e417c27000 r--p 00000000 08:03 2228319      /usr/bin/bash	//只读数据段 编译的时候地址就固定，只读
55e417c27000-55e417d06000 r-xp 0002f000 08:03 2228319      /usr/bin/bash  //可读可执行的代码段
55e417d06000-55e417d40000 r--p 0010e000 08:03 2228319      /usr/bin/bash
55e417d41000-55e417d45000 r--p 00148000 08:03 2228319      /usr/bin/bash
55e417d45000-55e417d4e000 rw-p 0014c000 08:03 2228319      /usr/bin/bash//全局变量，静态变量等，
55e419574000-55e4196df000 rw-p 00000000 00:00 0            [heap]  						//堆段
7ffe5f5d0000-7ffe5f5f1000 rw-p 00000000 00:00 0            [stack]						//栈段
7ffe5f5f2000-7ffe5f5f6000 r--p 00000000 00:00 0            [vvar]
7ffe5f5f6000-7ffe5f5f8000 r-xp 00000000 00:00 0            [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0    [vsyscall]

----------------------------------------------------------------------------
  
stack 是线程栈区域，通常用于存放函数调用的参数和局部变量等；
vvar 是一个Linux内核的安全特性，用于防止一些攻击，存放一些进程相关的变量；
vdso 是一种系统调用的方式，用于在用户态和内核态之间传递数据；
[vsyscall] 是一种快速系统调用的方式，用于提高系统调用的性能。
```

<img src="/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-07 11.32.38.jpg" style="zoom:50%;" />



虚拟地址

 <img src="/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-07 11.39.32.jpg" style="zoom:50%;" />

 

### 看程序的内存分布情况



程序

```c

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

int global_a =5;																// rw-p

int func(){
    static int func_a =6;												rw-p
    int noStatic =5;														[stack]
    printf("func_a :%p\n",&func_a);
    printf("noStatic :%p\n",&noStatic);
}


int main(){
  char *name="minlang";												r--p 只读不可以修改 因为修改之后 长度不一样
    int main_a=4;															 	[stack]
    int *heap_a=(int *)malloc(sizeof(int));			[heap]
    printf("global_a :%p\n",&global_a);						
    printf("main_a addr:%p\n",&main_a);					  
    func();
    printf("h_a addr:%p\n",heap_a);
    printf("当前进程 %d\n",getpid());
    getchar();
    return 0;
}
```

 

输出

```bash
global_a :0x55e57ab75010         rw-p
main_a addr:0x7fff9526caac         [stack]
func_a :0x55e57ab75014							rw-p
noStatic :0x7fff9526ca84					[stack]
h_a addr:0x55e57b7b62a0							 [heap]
当前进程 65574
```

  

 cat  /proc/65379/maps

```bash
55e57ab71000-55e57ab72000 r--p 00000000 08:03 1980403                    /home/min122218/1.Unix高级编程/7.内存/a.out
55e57ab72000-55e57ab73000 r-xp 00001000 08:03 1980403                    /home/min122218/1.Unix高级编程/7.内存/a.out
55e57ab73000-55e57ab74000 r--p 00002000 08:03 1980403                    /home/min122218/1.Unix高级编程/7.内存/a.out
55e57ab74000-55e57ab75000 r--p 00002000 08:03 1980403                    /home/min122218/1.Unix高级编程/7.内存/a.out
55e57ab75000-55e57ab76000 rw-p 00003000 08:03 1980403                    /home/min122218/1.Unix高级编程/7.内存/a.out
55e57b7b6000-55e57b7d7000 rw-p 00000000 00:00 0                          [heap]
7f75fe600000-7f75fe628000 r--p 00000000 08:03 2234718                    /usr/lib/x86_64-linux-gnu/libc.so.6
7f75fe628000-7f75fe7bd000 r-xp 00028000 08:03 2234718                    /usr/lib/x86_64-linux-gnu/libc.so.6
7f75fe7bd000-7f75fe815000 r--p 001bd000 08:03 2234718                    /usr/lib/x86_64-linux-gnu/libc.so.6
7f75fe815000-7f75fe819000 r--p 00214000 08:03 2234718                    /usr/lib/x86_64-linux-gnu/libc.so.6
7f75fe819000-7f75fe81b000 rw-p 00218000 08:03 2234718                    /usr/lib/x86_64-linux-gnu/libc.so.6
7f75fe81b000-7f75fe828000 rw-p 00000000 00:00 0 
7f75fe89f000-7f75fe8a2000 rw-p 00000000 00:00 0 
7f75fe8b1000-7f75fe8b3000 rw-p 00000000 00:00 0 
7f75fe8b3000-7f75fe8b5000 r--p 00000000 08:03 2234381                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f75fe8b5000-7f75fe8df000 r-xp 00002000 08:03 2234381                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f75fe8df000-7f75fe8ea000 r--p 0002c000 08:03 2234381                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f75fe8eb000-7f75fe8ed000 r--p 00037000 08:03 2234381                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f75fe8ed000-7f75fe8ef000 rw-p 00039000 08:03 2234381                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fff9524d000-7fff9526e000 rw-p 00000000 00:00 0                          [stack]
7fff952a3000-7fff952a7000 r--p 00000000 00:00 0                          [vvar]
7fff952a7000-7fff952a9000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
```

 



### 段的形成



![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-07 12.20.23.jpg)





### 字符串的说明

```c
int main(){
    
   
    printf("当前进程 %d\n",getpid());
    char *str1="hello,beijing";
    char *str2="hello,beijing";
  	char buff[32]="hello,beijing";
  
  // char buff[32];			分配了32个字节的空间 buff是一个地址
  // buff ="hello,beijing";		改变常量的地址

    printf("str1 pointer addr:%p,value addr:%p\n",&str1,str1);
    printf("str2 pointer addr:%p,value addr:%p\n",&str2,str2);
		printf("&buff  :%p\n",&buff);
  	printf("buff  format(p) :%p\n",buff);
  	printf("buff:%s\n",buff)
    getchar();

    return 0;
}

当前进程 66398
str1 pointer addr:0x7fffe6ba7168,value addr:0x562e9441b019
str2 pointer addr:0x7fffe6ba7170,value addr:0x562e9441b019
&buff  :0x7ffe387c9bd0
buff  format(p) :0x7ffe387c9bd0
buff:hello,beijing
  
两个字符串的指针地址不一样，都在栈空间     				[stack]
两个指针指向的内容都在数据   数据段的只读区域 				r--p
```



<img src="/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-07 12.47.21.jpg" style="zoom:50%;" />

### 查看代码是否为变量提前分配好内存

**用nm 命令查看符号表是否为全局变量之类的**

```
nm a.out |grep value

//如果没有提前分配内存 是放在栈里面 提前分配内存的在编译的时候，就分配好内存了 

0000000000004014 D 已经初始化的全局变量
0000000000004024 B 为初始化的全局变量
0000000000004020 B 头文件里面未初始化的变量
0000000000004010 D 头文件已经初始化的变量
0000000000004018 d 函数内的静态变量
0000000000004028 b 函数内未初始化的变量

- D：该符号为数据符号，即可读写数据。
- d：该符号为本地数据符号，即仅在当前文件中可见的数据。
- B：该符号为未初始化数据符号，即可读写的数据段的一部分。
- b：该符号为本地未初始化数据符号，即仅在当前文件中可见的未初始化数据。

```



### 堆的内存解析:malloc



```
int main(){
    printf("pid:%d\n",getpid());
    char *p=(char *)malloc(1024);  

    printf("&p=%p\n",&p);           //p的地址存在栈里面
    printf("p=%p\n",p);              //P的内容在堆里面  malloc分配的
    strcpy(p,"hello,kitty\n");
    printf("Free before p:%s\n",p);
    free(p);                        //释放栈里面的空间            
    p=NULL;                         //释放空间之后,p不应该在指向原来的地址，应该指向空
    //strcpy(p,"hello,world");       //p不指向NULL 这段代码还可以实现
    printf("Free later p:%s\n",p);      //释放之后打印随机值，
    getchar();
    return 0;
}


```



### 文件的映射到虚拟内存中

文件映射（File Mapping）指的是将一个文件或一个文件的一部分映射到内存中，使得这个文件或者文件的一部分可以被当成内存来访问。在Linux/Unix中，文件映射可以使用`mmap`函数来实现。

`mmap`函数的作用是将一个文件或一个文件的一部分映射到进程的虚拟内存空间中。通过对虚拟内存的访问，就可以读写文件的内容。`mmap`函数的参数如下：

c

```c
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 
int munmap(void *addr, size_t length);		//释放映射
```

*   `addr`：映射区的开始地址，通常设置为`NULL`，表示让系统自动选择映射区的地址。
*   `length`：映射区的长度，单位是字节。
*   `prot`：映射区的保护方式，可以取下面的值之一：
   *   `PROT_NONE`：映射区不能被访问。
   *   `PROT_READ`：映射区可被读取。
   *   `PROT_WRITE`：映射区可被写入。
   *   `PROT_EXEC`：映射区可被执行。
   *   `PROT_READ|PROT_WRITE`：映射区可被读取和写入。
   *   `PROT_READ|PROT_EXEC`：映射区可被读取和执行。
   *   `PROT_READ|PROT_WRITE|PROT_EXEC`：映射区可被读取、写入和执行。
*   `flags`：标志参数，可以取下面的值之一或它们的组合：
   *   `MAP_SHARED`：与其他映射这个文件的进程共享映射区。
   *   `MAP_PRIVATE`：建立一个私有映射区，对该映射区的写操作不影响原文件。
   *   `MAP_FIXED`：将映射区放到指定的地址。
   *   `MAP_ANON`：匿名映射区，映射区不与任何文件关联。
*   `fd`：文件描述符，表示映射的文件。
*   `offset`：文件映射的偏移量。

`mmap`函数返回映射区的起始地址，如果出错则返回`MAP_FAILED`。映射区建立后，可以通过这个地址访问文件的内容。可以通过`munmap`函数来解除映射。





![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-10 10.23.56.jpg)

```

```

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-10 10.26.43.jpg)

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-10 10.30.38.jpg)

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-10 10.38.33.jpg)



## 文件的操作



**以下的库函数都是对系统调用的封装**

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-07 18.14.45.jpg)

```c

 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>

 int open(const char *pathname, int flags);
 int open(const char *pathname, int flags, mode_t mode);

 int creat(const char *pathname, mode_t mode);

 int openat(int dirfd, const char *pathname, int flags);
 int openat(int dirfd, const char *pathname, int flags, mode_t mode);

 /* Documented separately, in openat2(2): */
 int openat2(int dirfd, const char *pathname,
             const struct open_how *how, size_t size);
```



```
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>

 int open(const char *pathname, int flags);
 int open(const char *pathname, int flags, mode_t mode);
 flag:
 	O_RDONLY, O_WRONLY, or O_RDWR (read only ,wirte only,??)
 	可以按位或以下
	O_CREATE 	//如果文件不存在就需要创建 并且需要指定权限
	最终的权限会被umask 修改 .mode & ~umask
	
	O_EXCL :如果文件存在，会报错
	O_TRUNC：文件存在清空文件，如果文件不存在会创建文件
	O_APPEND： 追加的方式打开文件，文件的读写文件被定位在文件的末尾
	
	
	返回一个非负的文件描述符
	错误 -1 error会设置为相应的值
	
 	
```

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-09 14.12.37.jpg)

 

#

```
bash 下面 一下文件描述符默认是被占用的

0	标准输入	STDIN_FILENO				 键盘
1 标准输出	STDOUT_FILENO				 屏幕
2 标准错误输出	STDERR_FILENO		  屏幕

标准输出和标准错误输出 从不通的来源 
比如 用ls 命令 走的是标准输出
用tls 命令 走的是 错误标准输出  //tls命令不存在
```

### 文件的类型

```bash
第一个字符代表文件的类型

-rwxrwxr-x 1 min122218 min122218 16008  4月  9 14:34 a.out
							文件所有者	文件所属组
-	普通文件
d	文件夹文件
c 字符设备文件
b	快设备
p 管道文件
s socket 文件
l 软连接文件


第一组文件的所有者的权限
第二组文件所属于组的权限
第三组其他人的权限 

```

### umask 掩码

```
新文件创建的时候
-rw-rw-rw-  0666权限
umask 0002	去掉other w的权限
新建的文件文件权限变成 
-rw-rw-r--  other没有写的权限 
```

掩码 把相应位的权限拿掉



### open()函数

`open()` 是 Linux 系统调用中用于打开文件的函数。它的函数原型如下：

```
cCopy code
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

其中，`pathname` 是文件的路径名，可以是相对路径或绝对路径；`flags` 是打开文件时的标志，用于指定打开方式和访问模式；`mode` 是创建新文件时的访问权限。

具体来说，`flags` 可以有以下取值：

- `O_RDONLY`：以只读方式打开文件；
- `O_WRONLY`：以只写方式打开文件；
- `O_RDWR`：以读写方式打开文件；
- `O_CREAT`：如果文件不存在，则创建文件； 创建的时候要设置mode_t 权限 0777 0644 等灯
- `O_EXCL`：和 `O_CREAT` 一起使用，如果文件已经存在则返回错误；
- `O_TRUNC`：如果文件已经存在，且以写方式打开，则清空文件内容；
- `O_APPEND`：以追加方式打开文件，即在文件末尾写入数据。

`mode` 参数只有在使用 `O_CREAT` 标志创建新文件时才会使用。它指定了新文件的访问权限，具体取值可以参考 `chmod()` 函数。需要注意的是，新创建的文件权限默认会受到当前进程的 umask 值的影响。

需要注意的是，`open()` 函数返回的是一个文件描述符，而不是一个指向打开文件的指针。打开文件后，可以使用返回的文件描述符进行文件操作，例如读、写、关闭等。



### close()函数

文件指针有计数器，用close() 会计数器减1 ，计数器为0的时候，会释放资源

`close()` 是 Linux 系统调用中用于关闭文件的函数。它的函数原型如下：

```
cCopy code
#include <unistd.h>

int close(int fd);
```

其中，`fd` 是文件描述符，可以是由 `open()` 或 `dup()` 函数返回的任意整数。当 `close()` 函数成功执行时，它会将 `fd` 指定的文件描述符关闭，并释放相关的资源。

`close()` 函数在关闭文件时可能会出现一些错误，例如文件描述符无效、文件已经被关闭等等。此时，`close()` 函数会返回一个负整数错误码。在发生错误时，可以通过查看 `errno` 全局变量来获取具体的错误信息。

需要注意的是，在 Linux 中，进程退出时会自动关闭所有打开的文件描述符。因此，一般情况下不需要显式地调用 `close()` 函数来关闭文件。但是，在一些特殊的场景中，例如需要释放大量的文件描述符或者需要在进程中间关闭某个文件描述符等，手动调用 `close()` 函数就显得非常重要了。



###  read() 函数

**从文件描述符里面读取内容 放到buf中**

**读取错误返回-1，读取到末尾了返回0 ，成功 返回读取字符数量**

```c
NAME
       read - read from a file descriptor

SYNOPSIS
       #include <unistd.h>

       ssize_t read(int fd, void *buf, size_t count);
错误返回-1 成功返回读取大小的字节数 0代表到达了文件的末尾
  
  
buf	 读取的内容放到buff中
count:读取
 
```







### write() 函数

**向文件描述符写到追加到内容中**

```c
 #include <unistd.h>

 ssize_t write(int fd, const void *buf, size_t count);

返回值
	错误 -1 设置error
  成功世纪写入的文件字节数量
```




### lseek()函数

**重新定位文件的读写文字**

```c
NAME
       lseek - reposition read/write file offset

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       off_t lseek(int fd, off_t offset, int whence);
fd:
	文件描述符号
offset：
    指定了一个字节数
    unsigned int 
whence：
    SEEK_SET: 位置被设置在文件的offset个字节处    			// 文件的开始 +offset
    SEEK_CUR：位置在当前位置的offset字节处理						// 当前的位置 +offset
    SEEK_END：位置被设置在文件的大小+offset字节处理			// 文件最后 +offset
返回值：
    错误 -1 errno被设置
    成功 返回位置距离文件开头的字节数量
    
```



**linux cp命令的实现**

```c
#include <t_file.h>
#include <t_stdio.h>
#include <stdlib.h>

/**
 *  实现 拷贝cp 命令
 *  t—cp  源文件 目标文件
 *  
*/


int cp_file(int src_fd,int des_fd){
    int total=0;
    int r,w;
    char buff[20];
    while(r=read(src_fd,buff,20)){
        char *temp=buff;
        while(r >0 ){  //确保文件可以写进去
            w=write(des_fd,temp,r);
            r=r-w;
            total +=w;
            temp +=w;
        }
        
    }
    return total;  
}

int main(int argc,char *argv[]){
    if(argc != 3){
        printf("Usage: %s srcfile desfile\n",argv[0]);
        exit(-1);
    }

    ssize_t result;

    int src_fd = open(argv[1],O_RDONLY);
    if(src_fd == -1)E_MSG("open",-1);

    int des_fd=open(argv[2],O_WRONLY|O_CREAT|O_TRUNC,00644);
    if(des_fd == -1)E_MSG("open",-1);

    printf("Total charactes:%d\n",cp_file(src_fd,des_fd));



    printf("src_fd:[%d],des_fd:[%d]\n",src_fd,des_fd);
    close(src_fd);
    close(des_fd);
    return 0;


}
```



### 文件描述符的复制

linux的重定向就是文件描述符的复制实现的

系统提供的函数有两个

```c
#include <unistd.h>

int dup(int oldfd);  

复制文件描述符
  
  返回值：-1 error设置为相应的错误描述码

 int t=dup(1);   1为标准输出 往文件描述符 t里面写数据 就等于往屏幕输出那啥
```

```c
#include <unistd.h>
int dup2(int oldfd, int newfd);
```

**文件描述符重定向到标准输出**

```c
#include <t_file.h>
#include <t_stdio.h>
#include <stdlib.h>
#include <string.h>

//从文件到重定向到标准输出

int main(int argc,char * argv[]){
    if(argc !=2){
        printf("输入格式 %s filename\n",argv[0]);
        return -1;
    }
  
    int fd=open(argv[1],O_RDONLY);      //打开一个文件描述符号  
    if(fd==-1)E_MSG("open",-1);
    int bak=dup(0);                     //备份标准输入
    dup2(fd,0);                         //重新定向到 标准输入
    close(fd);                          //关闭打开文件的描述符
    char buff[30];                      //缓存
    int n;                              //实际读取的数字
    while( (n = read(0,buff,strlen(buff) )>0))
        write(1,buff,n);                    //往标准输出写东西
    dup2(bak,0);                         //恢复备份
    close(bak);                           //关闭备份的文件描素符号
    return 0;
}
```

**文件描述符重定向到标准输出**

```c
#include<t_file.h>
#include<t_stdio.h>
#include<string.h>

//重定向的文件名通过argv[1]传递给进程
//主要是操作文件描述符
// 复制文件描述符  int target=dup(src_fd);      src_fd 复制到一个新的文件描述符
//拷贝到新的文件描述符         dup2(fd1,fd2);      fd1的文件描述符 复制到 fd2  记得关闭fd1 已经不用了
//恢复文件描述符              dup2(target,src_fd2);         

//文件
int main(int argc,char *argv[]){
    // 0 , 1, 2

    char *msg="this is a test .... \n";
    char *enter="\n";
    int flags=O_WRONLY|O_CREAT|O_TRUNC;
    int fd=open(argv[1],flags,00644);           //fd=3  文件自带的文件描述符
    if(fd == -1)E_MSG("open",-1);
    int s_fd=dup(1);                            //s_fd=4 拷贝标准输出的文件描述符
    dup2(fd,1);                                 //打开的文件描述符复制到标准输出
    close(fd);                                  //关闭 打开文件的文件描述符
   for(int i=0;i<100;i++){
        
        write(1,msg,strlen(msg));               // 往文件的文件的描述符写
        write(s_fd,msg,strlen(msg));            // 往原来的标准输出描述写
   }
    dup2(s_fd,1);                                 // 恢复标准输出,s_fd 是之前备份的
    close(s_fd);                                  // 关闭备份的文件描述符
    write(1,msg,strlen(msg));                     // 再往显示器上面输出一边
    return 0;
}
```

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-09 23.10.43.jpg)

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-09 23.11.46.jpg)

### 文件的元数据

需要使用 ls -l file 粗略的查看文件元数据

或者使用stat 可以详细的查看文件的元数据

```bash
#:stat a.out 
File: a.out
Size: 16088           Blocks: 32         IO Block: 4096   regular file
Device: 803h/2051d      Inode: 1981228     Links: 1
Access: (0777/-rwxrwxrwx)  Uid: ( 1000/min122218)   Gid: ( 1000/min122218)
Access: 2023-04-10 12:04:15.526398860 +0800
Modify: 2023-04-10 12:04:14.330390536 +0800
Change: 2023-04-10 12:04:14.330390536 +0800
Birth: 2023-04-10 12:04:14.314390425 +0800
```

```
#:ls -li d2 

1981316 -rw-rw-rw- 1 min122218 min122218 0  4月 10 12:48 d2
```

**文件的inode 是什么**

```
inode（index node）是Unix和类Unix文件系统中的一个概念，每个文件和目录都会分配一个唯一的inode号，它包含了文件或目录的元数据信息，如文件类型、文件权限、所有者、大小、创建和修改时间、访问时间、数据块的地址等等。可以通过ls -i 命令查看文件的inode号。因为inode可以提供快速访问文件的元数据信息，所以Unix和类Unix系统都采用了inode这种数据结构来管理文件系统。
```

**数据块表是否在inode信息中**

```
数据块表通常不是在inode信息中。每个inode包含一些元数据，例如文件类型、文件权限和所有者信息等。数据块表是用于存储文件内容的磁盘块列表，这些块通常是分配给文件的。数据块表通常存储在与inode不同的磁盘块上，但是inode中包含指向数据块表的指针，这些指针指向存储数据块表的磁盘块。
```

获取文件的元数据

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

int stat(const char *pathname, struct stat *statbuf);

pathname 路径
statbuf 需要存入的数据缓存，
返回值 0
错误 -1 errno被设置

```

**struct stat结构体成员**

```c
struct stat 
  {
    __dev_t st_dev;	文件所在的设备 ID。
    __ino_t st_ino;	文件的 inode 号。
    __nlink_t st_nlink;	文件的硬链接数目。
    __mode_t st_mode;	文件类型和访问权限。
    __uid_t st_uid;	文件所有者的用户 ID。
    __gid_t st_gid;	文件所有者的组 ID。
    int __pad0;
    __dev_t st_rdev;	特殊文件的设备 ID。
    __off_t st_size;	文件的大小。
    __blksize_t st_blksize;	文件系统块的大小。
    __blkcnt_t st_blocks;	分配给文件的块数。
    struct timespec st_atim;	最后一次访问文件的时间戳。
    struct timespec st_mtim;	最后一次修改文件的时间戳。
    struct timespec st_ctim;	最后一次改变文件属性的时间戳。
    __syscall_slong_t __glibc_reserved[3];
};

//struct timespec st_birthtim：文件的创建时间戳（有些文件系统不支持此字段）。
```

 

 



### 软连接和硬连接

一个文件只有唯一的一个节点与之对应，但是却可以有多个文件名称与之对应

文件名 链接硬盘上的东西



**软连接** 又称为符号连接，类似于windows的快捷方式

```c
ln -s source target
```

**硬连接** 为本文件开设了一个新的文件名称

```
ln source target
	硬连接不允许连接文件夹
```



### 文件的时间

**访问时间**

```
对文件进行一次读操作，他的访问时间就会被修改 像cat more 💡
ls stat 不会对st_atime 时间进行修改
```

**修改时间**  

```
用vim 编辑之后保存， 他的st_mtime 就会改变
```

**状态时间**

```
chmod chown  改变文件的元数据的时候，状态时间就会改变

```

C文件的格式化时间

```
ctime(&时间戳)  返回字符串首先地址
```





### 用户组相关

```bash
root   :x       :0  :  0       :root :/root  :/bin/bash
用户名字:是否有密码:UID:初始组的GID:备注  :家目录  :SHELL路径 登陆的时候执行的第一个程序

用户名只是我们看 系统用UID 识别 
密码存在 /etc/shaow 里面
UID:
	0为超级用户 1-499为系统用户（伪用户的UID） 500～54435为普通用户的UID 
GID: 
	用户组的ID 一半创建用户的时候，会创建同名的用户组
	附加组：用户组可以加入其他的用户组
备注:
	没什么特殊作用
家目录:
登陆shell:

```

```
#:cat /etc/group

root:x:0:min122219
adm:x:4:syslog,min122218
cdrom:x:24:min122218
sudo:x:27:min122218
dip:x:30:min122218
plugdev:x:46:min122218
lpadmin:x:122:min122218
lxd:x:134:min122218
min122218:x:1000:
sambashare:x:135:min122218


第一个组名:第二个口令:组标识号:组内用户列表，不用的用户之间用逗号分割
密码是X 代表没有密码

root:x:0:min122219,min122218
root 用命令 : sudo usermod -aG root min122218 把min122218 添加到root 组里面


```



**uid 转换成用户**

```c
#include <sys/types.h>
#include <pwd.h>

struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);

找不到返回NULL errno不设置
  
struct passwd
{
char *pw_name;		/* Username.  */
char *pw_passwd;		/* Hashed passphrase, if shadow database
                                 not in use (see shadow.h).  */
__uid_t pw_uid;		/* User ID.  */
__gid_t pw_gid;		/* Group ID.  */
char *pw_gecos;		/* Real name.  */
char *pw_dir;			/* Home directory.  */
char *pw_shell;		/* Shell program.  */
};

```



**gid 转换成组名称**

```c
 #include <sys/types.h>
 #include <grp.h>

 struct group *getgrnam(const char *name);
 struct group *getgrgid(gid_t gid);

 The  getgrnam()  function  returns a pointer to a structure containing
       the broken-out fields of the record in the group database  (e.g.,  the
       local  group  file  /etc/group,  NIS, and LDAP) that matches the group
       name name.
  

 struct group
{
  char *gr_name;		/* Group name.	*/
  char *gr_passwd;		/* Password.	*/
  __gid_t gr_gid;		/* Group ID.	*/
  char **gr_mem;		/* Member list.	*/
};
```



**文件类型**

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-11 00.09.43.jpg)

**查看文件的元信息代码**

```c
// ./a.out filename 查看文件的元信息 

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <t_stdio.h>
#include <time.h>
#include <pwd.h>
#include <grp.h>

//int stat(const char *pathname, struct stat *statbuf);

int main(int argc,char* argv[]){
    if(argc !=2){
        printf("Usage %s filename\n",argv[0]);
        return -1;
    }

    //声明一个结构用来存储新词
    struct stat buf;

    //获取文件元数据信息
    int s=stat(argv[1],&buf);
    if(s==-1)E_MSG("stat",-1);


    printf("file size   :%ld\n",buf.st_size);
    printf("links       :%lu\n",buf.st_nlink);
    printf("inode       :%lu\n",buf.st_ino);
    printf("uid         :%u\n",buf.st_uid); //通过UID找到字符名字？？？
    printf("gid         :%u\n",buf.st_gid);
    
    long int timestape=buf.st_mtim.tv_sec;        //时间戳转换成long int类型
    struct tm *p=gmtime(&timestape);              //返回时间结构的指针去接收他
#if 0 
    printf("用结构接收的时间是 %d-%d-%d %d:%d:%d\n",(p->tm_year +1900),p->tm_mon +1,p->tm_mday,
    p->tm_hour + 8,p->tm_min,p->tm_sec);
#endif
    //time.h头文件ctime()的函数
    printf("modify time :%s",ctime(&timestape));

    struct passwd * ws = getpwuid(buf.st_uid);
    printf("User        :%s\n",ws->pw_name);
    printf("passwd      :%s\n",ws->pw_passwd);
    printf("Home dir    :%s\n",ws->pw_dir);
    printf("group Name  :%s\n",getgrgid(buf.st_gid)->gr_name);
    printf("file mode   :%o\n",buf.st_mode);
    printf("file mode2  :");

    switch (buf.st_mode & S_IFMT) {   
           case S_IFBLK:  printf("b");        break;
           case S_IFCHR:  printf("s");        break;
           case S_IFDIR:  printf("d");        break;
           case S_IFIFO:  printf("p");        break;
           case S_IFLNK:  printf("l");        break;
           case S_IFREG:  printf("-");        break;
           case S_IFSOCK: printf("s");        break;
           default:       printf("unknown?\n");                break;
    }

    (buf.st_mode & 0b100000000) ? printf("r"):printf("-");
    (buf.st_mode & 0b10000000)  ? printf("w"):printf("-");
    (buf.st_mode & 0b1000000)   ? printf("x"):printf("-");
    (buf.st_mode & 0b100000)    ? printf("r"):printf("-");
    (buf.st_mode & 0b10000)     ? printf("w"):printf("-");
    (buf.st_mode & 0b1000)      ? printf("x"):printf("-");
    (buf.st_mode & 0b100)       ? printf("r"):printf("-");
    (buf.st_mode & 0b10)        ? printf("w"):printf("-");
    (buf.st_mode & 0b1)         ? printf("x\n"):printf("-\n");









#if 0
    struct stat 里面的mode 是一个无符号整型

    按位 0170000  后面的的12位不要 按8进制 后面4个8进制位不要 是各种权限

    st_mode  100664
            0170000  &
            0100000  结果为普通文件


    #define	__S_IFMT	0170000	
    #define	__S_IFDIR	0040000	/* Directory.  */
    #define	__S_IFCHR	0020000	/* Character device.  */
    #define	__S_IFBLK	0060000	/* Block device.  */
    #define	__S_IFREG	0100000	/* Regular file.  */
    #define	__S_IFIFO	0010000	/* FIFO.  */
    #define	__S_IFLNK	0120000	/* Symbolic link.  */
    #define	__S_IFSOCK	0140000	/* Socket.  */
#endif
    




    return 0;
}

```



### 文件夹

**文件夹的权限**

****

1. 读权限（r）： 允许用户查看目录中的文件和子目录列表。对于文件夹，读权限用字母 "r" 表示，对应数值为 4。
2. 写权限（w）： 允许用户在目录中创建、删除和重命名文件和子目录。对于文件夹，写权限用字母 "w" 表示，对应数值为 2。
3. 执行权限（x）： 允许用户访问目录中的文件和子目录以及更改到该目录。对于文件夹，执行权限用字母 "x" 表示，对应数值为 1。

**文件夹的操作**

****

1.opendir 打开文件夹

```
 #include <sys/types.h>
 #include <dirent.h>

 DIR *opendir(const char *name);
 
 
 错误返回NULL 成功返回文件夹流的地址
 
```

2.closeir  关闭文件夹流

```
 #include <sys/types.h>

 #include <dirent.h>

 int closedir(DIR *dirp);
```

3.readdir 

```
 #include <dirent.h>

 struct dirent *readdir(DIR *dirp);
```



### 文件锁

****

**使用系统调用fcntl 函数**

fcntl 函数用于操作已经打开的文件描述符。它可以完成很多与文件描述符相关的操作，例如复制文件描述符、修改文件状态标志等。

fcntl 函数的原型如下：

```c
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* arg */);

fd：需要操作的文件描述符
cmd：操作命令，可以是下列命令之一：
  F_DUPFD：复制文件描述符
  F_GETFD：获取文件描述符标志
  F_SETFD：设置文件描述符标志
  F_GETFL：获取文件状态标志
  F_SETFL：设置文件状态标志
  F_GETLK：获取文件锁
  F_SETLK：设置文件锁（非阻塞） //遇到有锁就报错
  F_SETLKW：设置文件锁（阻塞）	//遇到有锁就等开其他进程解锁 
  
  成功返回0 错误返回-1 设置errno
  
arg：
    struct flock {   //file lock
      
     ...
     short l_type;    /* Type of lock: F_RDLCK,  读锁 写锁 和 解锁和
                         F_WRLCK, F_UNLCK */
     short l_whence;  /* How to interpret l_start:  					偏移
                         SEEK_SET, SEEK_CUR, SEEK_END */
     off_t l_start;   /* Starting offset for lock */
     off_t l_len;     /* Number of bytes to lock */
     pid_t l_pid;     /* PID of process blocking our lock				
     
                         (set by F_GETLK and F_OFD_GETLK) */
               ...
      };

```



```c


  


返回值
    成功0 错误-1 errno被设置
```




<img src="/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-11 14.55.57.jpg" style="zoom:50%;" />

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-11 14.59.58.jpg)

### 关于文件的其他系统调用 和 vfs 文件系统

****

```
文件权限	:access()
文件夹操作 :chdir()  mkdir() rmdir()
文件路径	：getcwd() basename（） basename()
链接			：link() unlink() symlink()
改文件名称：rename()
改权限: chmod()

```

Vfs 文件系统

****

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-12 11.51.50.jpg)

**task_stuct 是什么**

```
task_struct是Linux内核中的一个结构体，表示一个进程或线程的状态和属性。它包含了该进程或线程的各种信息，例如进程ID、父进程ID、进程状态、进程优先级、进程使用的CPU时间、内存管理信息、文件描述符表等等。task_struct结构体定义在<linux/sched.h>头文件中。
```

**fs_stuct 是什么**

```
fs_struct是Linux内核中的一个结构体，它包含了与文件系统相关的信息，比如当前工作目录、打开文件列表、文件系统的超级块等等。每个进程都拥有自己的fs_struct结构体，它被存储在进程的task_struct结构体中。通过current->fs可以访问当前进程的fs_struct结构体。
```

**files_stuct是什么**

```
files_struct是Linux内核中一个用来存储进程打开的所有文件的数据结构，每个进程都有一个files_struct结构体，里面包含了该进程打开文件的信息，如文件描述符表、文件表、句柄等等。它是进程的全局变量之一，由内核为每个进程分配和初始化。files_struct结构体在Linux内核中的定义位于include/linux/fdtable.h文件中。
```

**files_stuct 中的fd_array数组里面是什么？**

```
files_struct 结构体中的 fd_array 数组是一个指针数组，其中每个指针指向一个 file 结构体，表示进程打开的文件的信息。每个 file 结构体中包含了文件描述符、文件状态标志、文件操作方法等信息。当进程打开文件时，文件描述符被放入进程的文件描述符表中，与一个 file 结构体关联。在使用该文件描述符进行 I/O 操作时，操作系统就可以通过该结构体中的信息来进行文件操作。
```

**file结构体中有什么**

```
file 结构体是 Linux 内核中的一个结构体，用于表示打开的文件。在内核中，每个打开的文件都与一个 file 结构体相关联。下面是 file 结构体中的一些重要字段：

struct file_operations *f_op：这个指针指向与文件相关的操作函数，例如 read、write、open、close 等等。文件系统会注册相应的操作函数，以便内核在处理文件时调用这些函数。

struct inode *f_inode：这个指针指向文件所在的 inode 结构体，inode 包含了文件的元数据，例如文件的类型、权限、大小、时间戳等等。

const struct cred *f_cred：这个指针指向打开文件的进程的安全凭证，用于权限检查和访问控制。

unsigned int f_flags：这个字段包含了文件的标志位，例如读写模式、阻塞/非阻塞模式、文件状态标志等等。

atomic_t f_count：这是一个计数器，用于记录有多少个进程正在引用这个 file 结构体。当引用计数为零时，这个 file 结构体会被释放。

void *private_data：这个字段是一个指针，用于存储文件私有数据，例如打开文件的进程的上下文信息等等。
```

**inode 存储在硬盘**

```
是的，inode信息通常存储在硬盘的超级块中。每个文件系统有一个超级块，超级块中存储着文件系统的元信息，包括文件系统类型、块大小、inode数量、块数量等信息。inode表则存储在文件系统的一部分中，每个inode描述了一个文件的元信息，包括文件的访问权限、所有者、文件大小、时间戳以及文件数据存储的物理地址等信息。
```

**inode 结构体里面有什么 分别有什么作用**

```
inode 结构体是文件系统中的一个重要概念，它存储了一个文件的元数据，包括文件的访问权限、时间戳、文件类型、数据块所在的位置等信息。inode 结构体通常由文件系统在文件创建时创建，存储在文件系统中的一个位置，以供后续读取和修改。

在 Linux 系统中，inode 结构体的定义通常存储在 /usr/include/linux/fs.h 文件中，常见的字段包括：

mode: 文件访问权限（读、写、执行）和类型（普通文件、目录、符号链接等）
uid: 文件所有者的用户 ID
gid: 文件所有者的组 ID
size: 文件大小
atime：文件最后访问时间
mtime：文件最后修改时间
ctime：文件创建时间
blksize：文件所使用的块大小
blocks：文件占用的数据块数量
i_blocks：文件占用的物理块数量
除此之外，inode 结构体还包含了指向数据块的指针，用于描述文件数据在磁盘上的存储位置。因为每个 inode 结构体只能描述一个文件，所以文件系统会根据需要创建多个 inode 结构体，以便存储所有的文件元数据。
```





## 进程的管理



### 什么是进程

****

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-12 12.51.13.jpg)

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-12 12.53.48.jpg)

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-12 12.55.26.jpg)



![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-12 13.00.44.jpg)


**ps aux**
```

																								状态					程序所在的路径
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.1 168184 13492 ?        Ss   4月11   0:04 /sbin/init splash
root           2  0.0  0.0      0     0 ?        S    4月11   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        I<   4月11   0:00 [rcu_gp]
root           4  0.0  0.0      0     0 ?        I<   4月11   0:00 [rcu_par_gp]
```

**top**

```
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  13371 min1222+  20   0   21996   4188   3356 R   1.0   0.1   0:00.09 top
     15 root      20   0       0      0      0 I   0.3   0.0   0:25.50 rcu_preempt
    614 systemd+  20   0   14828   6188   5392 S   0.3   0.1   1:48.87 systemd-oomd
```



### 查看进程的路径

***

使用ps命令查看进程路径的方法有多种，下面列出其中两种常用方法：

1. 使用 ps 命令配合 ls 命令：

   ```
   $ ps -ef | grep <进程名>
   ```

   然后在输出结果中找到进程的 PID，用 ls -l /proc/<PID>/exe 命令查看进程路径。例如：

   ```
   $ ps -ef | grep firefox
   root      1314     1  1 09:11 ?        00:00:08 /usr/lib/firefox/firefox
   $ ls -l /proc/1314/exe
   lrwxrwxrwx 1 root root 0 Jan 25 09:11 /proc/1314/exe -> /usr/lib/firefox/firefox
   
   ```

2.使用 pidof 命令查找进程 PID，然后使用 readlink 命令查看进程路径：

  ```
  $ pidof <进程名>
  $ readlink /proc/<PID>/exe

  ```

  ```
$ pidof firefox
	1314
$ readlink /proc/1314/exe
	/usr/lib/firefox/firefox

  ```

   







### 进程的创建

****

**使用系统调用fork()函数**

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
函数返回两次，父进程返回子进程的pid 错误返回-1

```

```c
#include <t_stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>


int main(){
    //在父进程中创建子进程
    pid_t pid;

    pid=fork();

    //函数调取失败
    if(pid == -1)E_MSG("fork",-1);

    //返回值为0的时候，说明是子进程返回的
    if(pid == 0){
        //子进程中执行的代码
        printf("Child   processing...%d \n",getpid());
    }else{
        //父进程中执行的代码
        printf("Father processing....%d \n",getpid());
    }


    //父子进程都可能执行到的代码

    printf("tail pid=%d\n",getpid());

   
    return 0;
}
```





![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-12 13.06.32.jpg)

![](/Users/min122218/Nas_Data/MD_FILE/现在的有可能不杂/allPic/Macdo2023-04-12 13.21.27.jpg)

### 进程的终止

****

**return 和 exit(3)的区别**

`return `如果在main函数终止 说明进程正常终止

`exit（3）`代表进程的正常终止，在程序的任何地方使用都会终止当前的进程

```
#include <stdlib.h>
void exit(int status);
功能：使进程正常终止
参数:
	status : 将status & 0377（0B111111111）的值返回给父进程，父进程调用wait（2）来回收
无返回值

 The exit() function causes normal process termination and the least
 significant byte of status (i.e., status & 0xFF) is returned to the
 parent (see wait(2)).
```



### 遗言函数

****

进程终止的时候执行的函数，进程调用return 或者exit（3） 从main函数返回的时候，执行的函数

遗言函数需要在进程还没有终止以前向进程注册，在进程终止的时候调用



**向进程注册遗言函数**

****

**atexit**  类似python里面的回调函数

```c
#include<stdlib.h>
int atexit(void (*function)(void)); //没有参数也没有返回值

成功返回0 错误返回非0
```

- 遗言函数的注册顺序和调用顺序相反 在栈空间 FILO
- 遗言函数注册一次会被调用一次,可以多次注册  
- 子进程继承父进程的遗言
- 进程的印象被更换的时候，进程的遗言函数也被覆盖





​	**on_exit** 注册带有参数的遗言函数

```c
 #include <stdlib.h>

 int on_exit(void (*function)(int , void *), void *arg);

需要自定义一个 void func(int n,(void *)arg) 的函数
n为 进程的返回值 ,如果在main中注册，main 函数最后的 return 值就是 n的值
arg 是唯一的参数 传参的时候 会转换 void * 格式 使用需要自行转换
	arg是参数
	成功返回0 错误非0
```













### 进程资源的回收

****

![](allPic/Macdo2023-04-16 20.53.09.jpg)

**wait()	系统调用函数**

阻塞等待子进程的结束，父进程回收其资源

```c
pid wait(int *wstatus);  //退出 状态码存入 wstatus 
功能：
	阻塞等待子进程结束，然后回收子进程的资源
参数:
	status:用来存储子进程的退出状态码
返回值:
	成功 终止子进程的pid
	失败 -1 errno 被设置	
	

```

**waitpid()	系统调用函数**

阻塞等待子进程的结束，父进程回收其资源

```c
pid_t waitpid(pid_t pid, int *wstatus, int options);

参数:
	pid：指定要等待回收的子进程pid
    	<-1 : pid 的绝对值指定了进程组的id 等待该组的子进程的终止
      -1  : 等待任意子进程   完全等同于 wait(pid)
      0	  :	等待与父进程同组的子进程
      >0  : 指定了要等带的子进程的pid
        
  status:用来存储子进程的退出状态码
  options:	0 阻塞等待子进程结束
    			WNOHANG 非阻塞等待 （如果子进程还没结束就返回）
返回值:
	成功：终止子进程的pid，如果 options的值为WNOHANG 要回收的子进程还没有结束，返回0
  错误： -1 errno做相应的设置
```

**检测子进程的退出状态码**

  `WIFEXITED(wstatus) `:如果进程正常终止，返回真这种情况下可以使用宏
  `WEXITSTATUS(wstatus)` //获取进程的退出状态码
  `WTERMSIG(wstatus)`：//如果进程是被新号打断，返回真，这种情况下可以使用宏
  `WTERMSIG(wstatus)`  //获取打断进程的信号的编号
  `WCOREDUMP(wstatus)`:这个函数会检查程序是否被其他进程或者被操作系统信号杀死

**给进程发送信号**

```bash
kill -9 进程pid

2：SIGINT，中断信号，用于终止进程。
3：SIGQUIT，退出信号，用于终止进程并生成核心转储文件。
9：SIGKILL，强制终止信号，用于强制终止进程。
```





### 孤儿进程和僵尸进程

****

**孤儿进程**：父进程已经终止，子进程还没有结束,将子进程的父进程设置为init进程，这样的子进程被称为孤儿进程,init 称为孤儿院

```c

int main(){

    pid_t pid =fork();
    if(pid==-1)E_MSG("fork",-1);
    if(pid ==0){
        printf("1.father pid = [%d]\n",getppid());
        printf("2.child pid = [%d]\n",getpid());
        sleep(2); //睡一秒 主进程已经结束
        printf("3.father pid = [%d]\n",getppid());  //父pid 为1,变为孤儿进程
        printf("4.child pid = [%d]\n",getpid());
    }else{
        sleep(1);
        printf("5.father pid = [%d]\n",getpid());
    }    
    
    return 0;
}
```

```bash
#:./a.out  执行结果
1.father pid = [15407]
2.child pid = [15408]
5.father pid = [15407]
#:3.father pid = [1]
4.child pid = [15408]
```

**僵尸进程**： 子进程已经结束，但是父进程还没有回收子进程的资源，这时候子进程处于僵尸状态，称这样的子进程为孤儿进程

​					

```c
int main(){

    pid_t p=fork();
    if(p==-1)E_MSG("fork",-1);

    if(p==0){
        exit(0); //子进程直接退出
    }else{
        //sleep(2);
        getchar();
        wait(NULL); //不回收？？子进程的资源

    }
#if 0
min1222+   15013  0.0  0.0   1920   516 pts/10   S+   16:03   0:00 ./a.out
min1222+   15014  0.0  0.0      0     0 pts/10   Z+   16:03   0:00 [a.out] <defunct>
                                                僵尸状态
  
父进程结束后会回收
#endif
    return 0;
}
```



### 进程的映像 是什么

****

进程的映像（image）是指进程在内存中的状态，包括代码、数据、栈等。它是操作系统中的一个概念，表示进程在内存中的存储状态，包括代码段、数据段、堆栈等。

在进程被创建后，操作系统会为它分配一块内存区域，这个区域包含了进程的所有信息，也就是进程映像。进程映像中的代码段、数据段和堆栈段分别对应了进程中的代码、数据和栈。进程映像还包括进程打开的文件、动态链接库、进程环境变量等信息。

进程映像的创建和管理是操作系统的重要功能之一，它直接影响到进程的运行和性能。在操作系统中，进程映像通常由虚拟内存机制来管理，操作系统会为进程分配一定的虚拟地址空间，映射到物理内存中，并根据需要进行页面置换、内存回收等操作，以保证进程的正常运行和系统的性能。

​	

### 进程映像的更新

****

![](allPic/Macdo2023-04-17 08.58.21.jpg)

![](allPic/Macdo2023-04-17 09.27.15.jpg)



![](allPic/Macdo2023-04-17 09.38.43.jpg)

![](allPic/Macdo2023-04-17 09.40.11.jpg)



![](allPic/Macdo2023-04-17 09.48.41.jpg)

![](allPic/Macdo2023-04-17 11.36.55.jpg)

**exec家族们 是对 execve库函数的封装**

execve 函数是 Unix/Linux 系统中的一个系统调用，用于将当前进程替换为指定程序的进程。它的函数原型如下：

```c
int execve(const char *pathname, char *const argv[], char *const envp[]);
```



1. pathname：要执行的程序的路径名。可以是绝对路径或相对路径。如果是相对路径，则相对于当前工作目录。

2. argv：程序的命令行参数。它是一个指向字符串数组的指针，每个字符串代表一个命令行参数。数组的最后一个元素必须为 NULL，表示参数列表的结束。

3. envp：程序的环境变量。它是一个指向字符串数组的指针，每个字符串代表一个环境变量。数组的最后一个元素必须为 NULL，表示环境变量列表的结束。

4. execve 函数执行成功时不会返回，它将当前进程的代码段、数据段、堆栈等全部替换为新程序的代码段、数据段、堆栈等。如果发生错误，则返回 -1，并设置 errno 变量来指示错误原因。

   

`execve`函数是一个系统调用，它用于启动一个新进程并用新进程替换当前进程。当调用`execve`函数时，当前进程的代码、数据、堆栈等信息会被新程序替换。因此，`execve`函数不会返回，除非调用失败。如果调用成功，则当前进程已经变成了新程序，直接执行新程序的代码。如果调用失败，`execve`函数会返回-1，并将`errno`设置为相应的错误码，此时应该根据错误码进行相应的处理。

 

**打印当前当前当前终端的信息**

```bash
ps -o pid,ppid,pgrp,comm

    PID    PPID    PGRP COMMAND
   3108    2826    3108 bash
  19986    3108   19986 ps
  
在bash 中调用了fork
fork 里面调用了setpgid 将ps进程设为另一个组的组长
```

**exec家族代码实例**

```c
 #include <unistd.h>

 extern char **environ;		//全局的环境变量

//执行list 的参数 NULL 结尾  需要自己指定路径
 int execl(const char *pathname, const char *arg, ...
                 /* (char  *) NULL */);

//在环境变量里面找，然后执行命令列表
 int execlp(const char *file, const char *arg, ...
                 /* (char  *) NULL */);

 int execle(const char *pathname, const char *arg, ...
                 /*, (char *) NULL, char *const envp[] */);

//执行指针数组里面的命令,需要NULL结尾 需要自己指定路径，
 int execv(const char *pathname, char *const argv[]);

//在环境变量里面 执行指针数组里面的命令,需要NULL结尾 
 int execvp(const char *file, char *const argv[]);
 int execvpe(const char *file, char *const argv[],
                 char *const envp[]);
```

**execl** 执行 list 列表

```c
int main(){

    pid_t pid=fork();
    if(pid==-1)E_MSG("fork",-1);
    if(pid==0){
        printf("child process...\n");

        //exec list 执行列表 NULL 结尾
        execl("/usr/bin/gcc","gcc","-E","-P","1.fork.c","-o","fuck.c",NULL);


        perror("execl");
        exit(0);
    }else{
        wait(NULL);   //父进程阻塞阻塞等待回收资源
    }
    return 0;
}
```



**execvp** 在 环境变量里面执行vector 里面的命令

v

```c
int main(){
    pid_t pid=fork();
    if(pid==-1)E_MSG("fork",-1);
    if(pid==0){
        printf("child process...\n");
        
        
        //更新进程的映像 后面的代码不执行了，因为函数没有返回值
        execlp("ps","ps","-o","pid,ppid,pgrp,comm",NULL); // 空结尾

        //执行效果和上面一样
        execl("/bin/ps","ps","-o","pid,ppid,pgrp,comm",NULL); // 空结尾
        

        //只有exec(3)家族执行失败的时候，才会执行到的代码
        perror("execlp");
        exit(0);
    }else{
        wait(NULL);
    }
    return 0;
}
```







### 进程使用环境变量

***

使用库函数操作环境变量

**获取环境变量**

```c
char *getenv(const char * name);		

功能 获取环境变量
 
```



**设置新的环境变量**

```c
int putenv(char *string);

功能：
	将字符串设置为环境变量
参数：
	String 参数 以"name=value"的字符串，将这个字符串设置到进程的环境变量中，如果进程中有和name痛吗的环境变量，使用value替换掉原来的值，如果没有同名的环境变量，这将字符串设置为进程的环境变量

返回值: 成功，返回0
  			错误，返回非0
切记：只是将字符串设置到进程环境变量中，而不是拷贝，如果string指向的字符串内容法身改变，则作相应的改变

```



**设置环境变量  **

```c
int setenv(const char *name, const char *value, int overwrite);

功能:	
	如果环境变量存在，根据overweite的值对环境变量操作，如果不存在，创造环境变量
参数：
  name 环境变量的名字
 	value 环境变量的值
  overwrite  0 如果环境变量已经在列表中，不改变环境变量的值 撤销操作
    				非0 如果环境变量已经在列表中，则使用value的值替换掉原来的值
返回值:成功 非0
  		错误 -1 errno 被设置 
    				
```



**删除环境变量**

```c
int unsetenv(const char *name);
功能:从环境变量列表删除环境变量，如果环境变量不存在，什么都不做
返回值
  成功 0
  不成功 非0
```



**清除所有环境变量**

```c
int clearenv(void);
功能：清除进程的环境变量列表，并将全局的environ 设置为NULL 没有参数
```



## 进程间的通信



#### 通信方式

****

进程间通信 (IPC) 是操作系统中非常重要的概念，它允许不同的进程之间互相传递信息并协作完成任务。以下是一些常用的进程间通信方式：

1. 管道（Pipe）：是一种半双工的通信方式，只能在具有父子关系的进程之间使用，并且只能支持单向数据传输。
2. 命名管道（Named Pipe）：也称为FIFO，它可以实现任意两个进程之间的通信，而且可以在无关的进程之间使用，支持双向数据传输。
3. 信号量（Semaphore）：它是一个计数器，用于多进程之间控制共享资源的访问问题，可以实现对临界区的互斥访问。
4. 消息队列（Message Queue）：是一种可在不同进程之间传递消息的通信机制，可以实现在已知进程之间有序的消息传递。
5. 共享内存（Shared Memory）：它是最快的一种 IPC 方式，可以将一块内存直接映射到多个进程的地址空间，从而实现多进程之间的数据共享。
6. 套接字（Socket）：可以实现网络中不同主机上进程之间的通信，也可在同一主机的不同进程之间使用。

不同的 IPC 方式各有优缺点，具体的选择需要根据场景和需求来确定。



****

![](allPic/Macdo2023-04-17 13.06.57.jpg)

#### 管道

****

每个进程都有自己的内存空间，时间片轮到该进程的时候，进程可以使用自己的用户空间 + 共享的内核空间，两个进程通信就可以利用内核空间通信

**有名管道** 文件系统

```c
int mkfifo(const char *pathname, mode_t mode);
功能：
  	创建一个有名管道
参数：
  		pathname 指定要创建的文件的名字，管道类型文件
     	mode 管道文件的权限
返回值:
			成功 0  错误返回 -1 errno 被设置
注意：
   一旦创建管道类型的文件，就可以向使用普通文件一样是这个文件实现进程间的通信，读写均阻塞，需要两个进程配合使用
```

**无名管道** 内和空间分配内存，不分配到文件系统当中

```c
int pipe(int pipefd[2]); 创建无名管道
  参数为 一个2个元素的数组 数组第1个文件描述符用于读取管道内容  第2个文件描述符接收管道内容
  返回值 0 代表成功 -1 失败
```

![](allPic/Macdo2023-04-17 13.13.47.jpg)

![](allPic/Macdo2023-04-17 13.15.02.jpg)

![](allPic/Macdo2023-04-17 13.11.37.jpg)

![](allPic/Macdo2023-04-17 13.16.47.jpg)

![](allPic/Macdo2023-04-17 13.19.14.jpg)

**使用无名管道**

```c
/**
 *  无名管道
 * 
*/

#include <t_stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>

const char * data="hello,myname is minliang\n";

int main(){
    
    int fd[2];
    char buff[128];
    //fd[0] 管道的读端口 fd[1] 负责管道的写端口
    //创建管道 文件描述符传入参数里面
    int pp=pipe(fd);
    if(pp==-1){  //创建失败
        perror("pip2");
        return -1;
    }

    //创建子进程
    pid_t p=fork();
    if(p==-1)E_MSG("fork",-1);
    if(p==0){  //子进程
        close(fd[1]);                    //关闭子进程的的写端口;
        
                                        //如果管道没有数据阻塞等待
        int r = read(fd[0],buff,128);   //从管道读取数据写入到缓存中
        write(1,buff,r);                //向标准输出写读取到的缓存
        close(fd[0]);
        exit(0);
    }else{
        close(fd[0]);                       //父进程关闭管道的端口
        write(fd[1],data,strlen(data));     //向管道写入数据
        close(fd[1]);                       //父进程关闭写端
        printf("the message from father processing\n");
        wait(NULL);                         //阻塞等待子进程的结束 要放在后面

    }

    printf("Bye-bye\n");


    return 0;
}

```

**使用有名管道**

创建管道	 (也可以用创建管道命令 mkfifo)

```c
#include <t_stdio.h>
#include <sys/types.h>
#include <sys/stat.h>

int main(int argc,char *argv[]){
    int ff=mkfifo(argv[1],0644); //创建管道文件
    if(ff==-1)E_MSG("mkfifo",-1);
    else{printf("the fifo file:%s be created\n",argv[1]);}

    return 0;
}
```

向有名管道写数据 （进程向有名管道写入数据后,会一直阻塞等待，知道有进程读取完管道的内容，进程才会结束,管道的文件大小一直为0）

```c
#include <t_stdio.h>
#include <t_file.h>
#include <string.h>

int main(int argc,char * argv[]){
    char* msg="this is a test......";

    //以写的方式打开文件
    int fd=open(argv[1],O_WRONLY);
    if(fd==-1)E_MSG("open",-1);
    
    
    write(fd,msg,strlen(msg));				//注意 如果管道内容没有被读取会一直等待管道内容被读取
    
    close(fd);
    return 0;
}
```

读取无名管道（进程开始读取管道文件的时候，如果管道内没有数据，会一直阻塞等待，知道有进程向管道写入数据后，并且读取完后，进程才会结束）

```c
#include <t_stdio.h>
#include <t_file.h>
#include <string.h>


int main(int argc,char * argv[]){

    char buff[128];                      //缓存
    int fd=open(argv[1],O_RDONLY);       //打开管道文件
    if(fd==-1)E_MSG("open",-1);

    int r=read(fd,buff,128);            //读取管道文件				//⚠️ 如果读取不到管道内的内容会阻塞等待
    write(1,buff,r);                    //写入到标准输出
    close(fd);                          //关掉文件描述符
    return 0;
}

```



#### 信号

****

![](allPic/Macdo2023-04-20 11.07.26.jpg)

![](allPic/Macdo2023-04-20 11.42.16.jpg)

![](allPic/Macdo2023-04-20 11.27.21.jpg)

![](allPic/Macdo2023-04-21 11.33.42.jpg)



查看操作系统提供的中断信号

`kill -l`

```bash
kill -l 

 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX

信号的编号，宏

2) SIGINT  终止进程Ctrl + C
20)SIGSTP  停止进程 Ctrl + Z
9) SIGKILL 杀死信号
11) 段错误，进程访问不属于自己的内存会触发操作系统给进程发送信号
12） 自己定义
14) 闹钟信号
17）SIGCHLD 子进程终止的时候，子进程给父进程发送SIGCHLD 信号  父进程等待子进程的17号信号



SIGSTOP(19)：该信号可以暂停一个进程，以便稍后将其恢复运行。
SIGCONT(18)：该信号相对于SIGSTOP，可以让因SIGSTOP而挂起的进程恢复运行。

  

```



**命令行给进程发消息**

```bash
kill -信号编号 线程pid
	
	kill -9 1234 给1234 信号发送9号信号
```



**代码给进程发送消息**

****

**KILL(2)**

```c
 #include <sys/types.h>
 #include <signal.h>

 int kill(pid_t pid, int sig);

返回值：成功返回0，失败-1
 扩充：给进程自己发送信号 
  	kill(getpid(),sig_num);//raise(3)的实现
```

**RAISE(3)   **

```c
 #include <signal.h>

 int raise(int sig);
功能:发送一个信号给调用者
  相当于 signal(getpid(),9);
```

**ALARM(2) ** 

```c
#include <unistd.h>

unsigned int alarm(unsigned int seconds	);
功能：
  在指定的时间产生SIGNALRM(定时) 信号，并将其传送给当前进程
参数：
  second 指定的秒数量
 返回值 返回上次设定的闹钟未完成时间时间值，如果上次闹钟已经执行，返回0
 注意：
  alarm(0) 取消原来设置的闹钟
```

```c
int main(void){

	alarm(5); //定时5秒 超时会给进程发送alarm 信号，停止进程
	int i=1;
	for(;i<500000;i++){
		printf("%d\n",i);
	}
	int time=alarm(0);  //取消alarm 闹钟 变量time 存放的是未觉时间 剩余时间
	
	#if 0
	alarm(1);			//如果定义的时间非0 会重新设置alarm时间
	#endif

	printf("alarm 剩余时间为%d 秒",time);
	return 0;

}

```

**让进程睡眠**

****

pause

```c
#include <unistd.h>

int pause(void);

功能:
	是当前的进程进入睡眠状态，知道有信号才到达 (可以sigal 自己定义信号函数)
返回值：
	-1 只有被信号打断的时候才返回-1，要不然会一直休眠;
```

```c
#include <unistd.h>
#include <stdio.h>
#include <signal.h>

//自定义的信号函数
void conti(int n){
    printf("pid : %d 接收到 %d号信号了,执行下面的代码\n ",getpid(),n);
}   

int main(){
    
    //注册函数到信号    
    signal(10,conti);

    printf("pause the program(pid %d,注册信号为10)...\n",getpid());
    pause();

    printf("countinue the progream...\n");
    return 0;
}
```



**信号的阻塞**

****

阻塞信号是指进程将某些信号设置为阻塞状态，从而在该状态下忽略它们。当一个信号被阻塞后，如果该信号被发送给进程，它不会被处理，也不会中断正在运行的系统调用或用户态进程代码。

通过调用`sigprocmask`函数可以实现对进程信号屏蔽集合（signal mask）的修改。该函数提供了一组参数来控制哪些信号要被添加到阻塞集合中，或从阻塞集合中移除

**进程的pcb中有两个数组，数组里面的是 位。只能是0 或者1  True or False**

blocking 数组 **信号到达进程时，它不会被处理**

```
0	进程对该信号不阻塞
1 进程阻塞该信号
```

pending 数组 **味觉信号，已经发生但是还没处理的信号**

```
0 该信号没有发生
1 该信号发生了还没有处理
```



**信号集**

```c
 #include <signal.h>

 int sigemptyset(sigset_t *set);

 int sigfillset(sigset_t *set);

 int sigaddset(sigset_t *set, int signum);

 int sigdelset(sigset_t *set, int signum);

 int sigismember(const sigset_t *set, int signum);
```





![](allPic/Macdo2023-04-21 11.53.07.jpg)



**设置进程信号掩码集**

****
**1把信号屏蔽掉**

```c
 #include <signal.h>

 /* Prototype for the glibc wrapper function */
 int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);

参数:
	how 取值
    SIG_BLOCK	: 将set信号集和原来的新号集做并集 设置为进程的信号掩码集   （成为掩码 信号失效失效）
    SIG_UNBLOCK：将set信号集和原来的新信集移除  设置为进程的信号掩码集  解除信号的颜吗集合
    SIG_SETMASK: 把信号集舍设置为进程的信号掩码集合 
	set
    用于指定的信号集合
  oldset
    用于保存原来的信号集 如果设置为NULL，标识不保存原来的信号集
      
  返回值：
      成功0
      错误 -1 errno被设置相应的错误码
```

**信号集**

```c
#include <signal.h>

/* Prototype for the glibc wrapper function */
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);

/* Prototype for the underlying system call */
int rt_sigprocmask(int how, const kernel_sigset_t *set,
                  kernel_sigset_t *oldset, size_t sigsetsize);

/* Prototype for the legacy system call (deprecated) */
int sigprocmask(int how, const old_kernel_sigset_t *set,
               old_kernel_sigset_t *oldset);

Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

sigprocmask(): _POSIX_C_SOURCE
  
sigprocmask函数用于查找或修改进程的信号屏蔽字，其参数包括：

how：表示如何修改信号屏蔽字。可以使用以下三个值之一：
    SIG_BLOCK：将当前信号屏蔽字与set指向的信号集合的并集替换。
    SIG_UNBLOCK：从当前信号屏蔽字中删除set指向的信号集合。
    SIG_SETMASK：用set指向的信号集合替换当前的信号屏蔽字。
  
set：指向信号集合的指针。如果set=NULL，则sigprocmask函数不执行任何操作。
  
oldset：输出参数，指向一个先前的信号屏蔽字的指针。如果oldset=NULL，则忽略此参数。
  （可以用于之后恢复信号）
```



**未决信号**

****

在Linux中，每个进程都有一个称为pending信号的列表，该列表包含进程当前正在等待处理的信号。 pending数组是指用于记录进程挂起（pending）信号状态的数据结构，在内核中维护该列表。

当信号被传递给进程时，它可能会立即处理，也可能被添加到该进程的pending信号列表中，以便稍后进行处理。 pending数组会记录哪些信号被挂起，待稍后进程再次检查时处理。这样有助于确保信号不会丢失，并能让进程按照预期的方式响应信号。

基于pending数组，进程可以实现选择性地阻塞或解除阻塞某些信号，以及确定当前是否有信号需要处理，从而实现更高效和精确的信号处理。



```c
//定义一个sigset_t的变量
sigset_t pset;

//获取进程的味觉信号集,pset存放的是进程的味觉信号集
sigpending(&pset);

//判断是否为味觉信号
int is=sigismember(&pset,2);
if(is ==-1) E_MSG("sigismember",-1);
is?printf("yes\n"):printf("NO\n");


2号信号是ctrl+c
已经设置为阻塞2号信号,pedding数组
当键盘没有发送 2号信号的时候 2号信号不是未觉信号，
但是发送了2号信号，pedding数组 会设置2号信号为True
```

#### system V IPC

****

system V IPC 分为一下三种，三种都要有唯一的一个键，然后用该键向操作系统申请三种不通的id（共享内存，消息队列，信号量集合）

1. 消息队列

2. 共享内存
3. 信号量集合

```bash
ipcs 命令
------ Message Queues -------- 消息队列
key        msqid      owner      perms      used-bytes   messages    

------ Shared Memory Segments -------- 共享内存
key        shmid      owner      perms      bytes      nattch     status      

------ Semaphore Arrays --------	信号量集合
key        semid      owner      perms      nsems     

```

三种都要有唯一个键，key 

首先要有一个键值，然后使用三种其中



```c
key_t ftok(const char *pathname, int proj_id); 

是的，proj_id是一个由用户定义的整数值，目的是确保同一路径名的不同消息队列有不同的标识符（即key）。在 ftok 函数中，如果同一个路径名和同一个proj_id都传递给函数，则它们将返回相同的key值，这样就可以创建指向同一个消息队列的多个进程之间进行通信。因此，通常情况下，使用固定的特定值或其他方法来生成唯一的proj_id会更好。值得注意的是，proj_id必须在0到255之间，并且唯一地在路径名下确定某个IPC（进程间通信）对象的key。
```



#### 共享内存

****

**创建共享内存的步骤**

1. `ftok()`函数向内核空间领取一个key_t 类型的 键
2. `shmget()` 用key_t 向操作系统申请共享内存的id (shmid)
3. `shmat()` 用共享内存id映射到（附加到调用进程的内存中） 返回值为void* 需要



首先要用ftok()函数获取一个weiyi的key 在内核空间中领取一个身份证 key 才能在内核空间中操作共享内存，消息队列 等等

多个进程使用共享内存的时候，对共享内存读取是异步的，会不稳定，可以采用信号对进程控制

比如进程A对共享内存操作的时候，进程A可以给进程B发送一个信号，让B进程暂停等等



<img src="allPic/Macdo2023-04-23 10.40.15.jpg" style="zoom:50%;" />

**共享内存的操作函数**

```c
 #include <sys/ipc.h>
 #include <sys/shm.h>

 int shmget(key_t key, size_t size, int shmflg);

参数
	key  用ftok()函数的返回值
	size   指定了共享内存段的大小
  shmflg
  	IPC_CREAT
  	IPC_EXCL
  	mode
返回值
  成功 返回共享内存短的id
  失败 -1 errno被设置

```





**使用共享内存**

****

```c
 #include <sys/types.h>
 #include <sys/shm.h>

 void *shmat(int shmid, const void *shmaddr, int shmflg);
功能:将共享内存段附加到进程的地址空间
参数:
	shmid:	
				指定了共享内存短的id，将这个共享内存短附加到进程的地址空间
  shmaddr:
				NULL 系统选择进程的具体地址空间
  shmflg:
				0
返回值:
		成功 附加到进程的具体地址
    错误(void *) -1
 
 
```

```c
int shmdt(const void *shmaddr);

功能：将共享内存短从进程地址空间解除附加
参数：
	shmaddr:指定了共享内存段的具体地址   shmat()的返回值
	
```



**示范代码**

****

新建一个共享内存并且写入数据

```c
#include <t_stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>

int main(int argc,char *argv[]){
    //获取一个SYSTEM V IPC 的键值

    key_t key=ftok(argv[0],32);
    printf("key=0x%x",key);
    if(key==-1)E_MSG("ftok",-1);

    //分配共享内存 内存页 按照4K来分配  4KB  
    //需要按位或 一下权限 IPC_EXCL 如果文件存在就失败
    //IPC_CREAT 新建
    //IPC_EXCL 如果文件存在就失败
    int shm=shmget(key,1024,IPC_CREAT|IPC_EXCL|0644);
    if(shm == -1)E_MSG("shmget",-1);

    printf("\nshmid:%d\n",shm);

    void *temp=shmat(shm,NULL,0);
    if(temp==(void *)-1)E_MSG("shmat",-1);

    strcpy(temp,"hello,kitty");
    printf("%s\n",(char *)temp);

    

    return 0;
}
```



读取共享内存的数据

****

```c
#include <t_stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>

int main(int argc,char *argv[]){
    //获取一个SYSTEM V IPC 的键值
    int shm=6;
	
    void *temp=shmat(shm,NULL,0);
    if(temp==(void *)-1)E_MSG("shmat",-1);

    strcpy(temp,"hello,kitty");
    printf("%s\n",(char *)temp);

    

    return 0;
}
```



**命令行释放共享内存**

***

要释放共享内存，可以使用`ipcrm`命令，该命令可用于删除由系统创建的IPC对象（例如消息队列，共享内存段和信号量）。下面是使用 `ipcrm` 命令释放共享内存的步骤：

1. 首先运行 `ipcs` 命令以获取系统中现有的IPC对象的列表。

2. 找到您要释放的共享内存段的ID，并记录它。

3. 使用以下命令释放共享内存段：

   DiffCopyInsertNew

   ```
   ipcrm -m <shmid>
   ```

   其中 `<shmid>` 是您想要释放的共享内存段的ID。

4. 最后，再次运行 `ipcs` 命令以确保已成功删除共享内存段。



#### 消息队列

****

1. `ftok()` 函数通常与消息队列相关，用于生成一个唯一的 `key_t` 类型的键值。这个键值可以被用来创建和访问系统中的消息队列。

2. `msgget()`创建消息队列id

3. 创建消息

   ```c
   struct msgbuf {  //消息队列的结构
       long mtype;
       char mtext[100];
   };
   
   struct msgbuf message;//创建消息队列
   message.mtype = 1;
   strcpy(message.mtext, "This is a test message.");
   ```

4. `msgsnd()`传递消息给消息队列

   ```c
   int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); //传递消息给消息队列
   
   if(msgsnd(msgid, &message, sizeof(message.mtext), 0) == -1)
   {
       perror("msgsnd");
       exit(1);
   }
   ```

5. `msgrcv()`接收消息队列里面的消息

   ```c
   ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
                         int msgflg);
   ```




**发送消息**

```c
#if 0
  ftok() 函数通常与消息队列相关，用于生成一个唯一的 key_t 类型的键值。这个键值可以被用来创建和访问系统中的消息队列。

  ftok() 函数需要两个参数：一个可访问的文件路径名和一个项目标识ID，通常用字符或数字表示。它会根据这两个参数计算并返回一个对应的键值。如果在不同的进程或代码片段中使用相同的文件路径名和项目标识ID参数，ftok() 函数将始终返回相同的键值。

  下面是一个示例代码，演示了如何使用 ftok() 函数来创建一个具有唯一键值的消息队列：
#endif
    
    
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    key_t key;
    int msgid;

    // Generate a unique key using ftok()
    key = ftok("message_queue.c", 'b');

    // Create the message queue with the generated key
    msgid = msgget(key, 0666 | IPC_CREAT);
    if (msgid == -1)
    {
        perror("msgget");
        exit(1);
    }
    printf("Message queue created with key %d.\n", key);

    return 0;
}

```

**接收消息**

```c
#if 0
	要将消息发送到消息队列中，可以使用 msgsnd() 函数。该函数需要指定消息队列的标识符、要发送的消息和消息的长度等参数。下面是一个示例代码，演示了如何将消息发送到消息队列中：
#endif 
  
  #include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/msg.h>

struct msgbuf {
    long mtype;
    char mtext[100];
};

int main()
{
    key_t key;
    int msgid;
    struct msgbuf message;

    // Generate a unique key using ftok()
    key = ftok("message_queue.c", 'b');

    // Access the message queue with the generated key
    msgid = msgget(key, 0666 | IPC_CREAT);
    if (msgid == -1)
    {
        perror("msgget");
        exit(1);
    }
    printf("Message queue created with key %d.\n", key);

    //Receive the message from the queue
    if(msgrcv(msgid, &message, sizeof(message.mtext), 1, 0) == -1)
    {
        perror("msgrcv");
        exit(1);
    }

    printf("Message received from the queue: %s\n", message.mtext);

    return 0;
}

```


​	

#### 信号量集（略）

****

**信号量集 是不是经常搭配共享内存使用**

是的，在进程间共享数据时，常常需要使用信号量集合和共享内存两种机制结合起来使用。共享内存用于在多个进程之间共享数据，而信号量集合则用于控制对共享内存的访问，防止并发访问造成的数据不一致或竞态条件等问题。

具体来说，在使用共享内存时，需要先创建一个共享内存段，并将该内存段映射到各个进程的地址空间中，从而实现多进程共享数据。然后，通过使用信号量集合来控制对共享内存段的访问，例如通过互斥信号量保证只有一个进程可以操作共享内存，或者使用条件信号量等待其他进程释放共享内存使用权等。

因此，信号量集合和共享内存是经常搭配使用的两种机制，用于在多进程程序中实现数据共享和同步。





使用信号量集合来控制多个进程对共享资源的互斥访问或同步操作。下面是一个简单的示例，演示了如何使用信号量集合：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int main()
{
    int semid;
    struct sembuf sb;

    // Create a semaphore set with three semaphores
    semid = semget(IPC_PRIVATE, 3, IPC_CREAT | 0666);
    if (semid == -1)
    {
        perror("semget");
        exit(1);
    }

    // Initialize the first and second semaphores
    semctl(semid, 0, SETVAL, 1); // Initialized to 1 (available)
    semctl(semid, 1, SETVAL, 0); // Initialized to 0 (not available)

    // Fork a child process
    pid_t pid = fork();
    if (pid == -1)
    {
        perror("fork");
        exit(1);
    }
    else if (pid == 0) // Child Process
    {
        // Acquire the second semaphore
        sb.sem_num = 1;
        sb.sem_op = -1;
        sb.sem_flg = 0;
        if (semop(semid, &sb, 1) == -1)
        {
            perror("semop");
            exit(1);
        }

        printf("Child Process has acquired the semaphore.\n");
        sleep(3);

        // Release the first semaphore
        sb.sem_num = 0;
        sb.sem_op = 1;
        sb.sem_flg = 0;
        if (semop(semid, &sb, 1) == -1)
        {
            perror("semop");
            exit(1);
        }

        printf("Child Process has released the semaphore.\n");
    }
    else // Parent Process
    {
        // Acquire the first semaphore
        sb.sem_num = 0;
        sb.sem_op = -1;
        sb.sem_flg = 0;
        if (semop(semid, &sb, 1) == -1)
        {
            perror("semop");
            exit(1);
        }

        printf("Parent Process has acquired the semaphore.\n");
        sleep(3);

        // Release the second semaphore
        sb.sem_num = 1;
        sb.sem_op = 1;
        sb.sem_flg = 0;
        if (semop(semid, &sb, 1) == -1)
        {
            perror("semop");
            exit(1);
        }

        printf("Parent Process has released the semaphore.\n");
    }

    // Remove the semaphore set
    semctl(semid, 0, IPC_RMID);

    return 0;
}

```

上面的代码创建一个包含三个信号量的信号量集合，并初始化第一个和第二个信号量。然后，它 fork 一个子进程，在子进程中获取第二个信号量，等待3秒钟，然后释放第一个信号量。在父进程中获取第一个信号量，等待3秒钟，然后释放第二个信号量。

我们使用 `semget()` 函数创建一个新的信号量集合，并为其中的每个信号量分配唯一的标识符。然后，使用 `semctl()` 函数对第一个和第二个信号量进行初始化，将它们的值分别设置为 1 和 0。

在子进程中，我们使用 `semop()` 函数获取第二个信号量，该函数需要指定信号量集合的标识符、要修改的信号量的编号和操作类型等参数。如果获取信号量失败，我们打印错误信息并退出程序。类似地，在父进程中，我们使用 `semop()` 函数获取第一个信号量，并等待3秒钟，然后释放第二个信号量。

最后，我们使用 `semctl()` 函数删除信号量集合，使其不再被使用。

需要注意的是，在使用信号量集合时，必须小心避免死锁和竞争条件。如果多个进程同时等待一个或多个信号量，就可能导致死锁。因此，应该确保每个进程在释放所有已经保持的信号量之前都能够正常退出。



**信号量搭配共享内存使用**

****



```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>

#define SHM_KEY 1234 // 共享内存键值
#define SEM_KEY 5678 // 信号量集合键值

#define SHM_SIZE 1024 // 共享内存大小
#define SEM_NUM 2 // 信号量数量

union semun {
    int val;               // Value for SETVAL
    struct semid_ds *buf;  // Buffer for IPC_STAT, IPC_SET
    unsigned short *array; // Array for GETALL, SETALL
};

int main()
{
    int shm_id;         // 共享内存标识符
    int sem_id;         // 信号量标识符
    char *shm_ptr;      // 共享内存指针
    struct sembuf sop;  // 信号量操作结构体
    union semun arg;    // 信号量控制操作参数

    // 创建共享内存段
    shm_id = shmget(SHM_KEY, SHM_SIZE, IPC_CREAT | 0666);
    if (shm_id == -1) {
        perror("shmget");
        exit(1);
    }

    // 映射共享内存
    shm_ptr = shmat(shm_id, NULL, 0);
    if (shm_ptr == (char *) -1) {
        perror("shmat");
        exit(1);
    }

    // 初始化信号量集合
    sem_id = semget(SEM_KEY, SEM_NUM, IPC_CREAT | 0666);
    if (sem_id == -1) {
        perror("semget");
        exit(1);
    }

    // 初始化互斥信号量为1
    arg.val = 1;
    if (semctl(sem_id, 0, SETVAL, arg) == -1) {
        perror("semctl");
        exit(1);
    }

    // 初始化条件信号量为0
    arg.val = 0;
    if (semctl(sem_id, 1, SETVAL, arg) == -1) {
        perror("semctl");
        exit(1);
    }

    // 写进程向共享内存写入数据
    if (fork() == 0) {
        printf("Writing to shared memory...\n");
        sleep(1);

        // 等待互斥信号量
        sop.sem_num = 0;
        sop.sem_op = -1;
        sop.sem_flg = SEM_UNDO;
        semop(sem_id, &sop, 1);

        // 向共享内存写入数据
        sprintf(shm_ptr, "Hello, world!");

        // 发送条件信号量
        sop.sem_num = 1;
        sop.sem_op = 1;
        sop.sem_flg = SEM_UNDO;
        semop(sem_id, &sop, 1);

        printf("Data written to shared memory.\n");

        exit(0);
    }

    // 读进程从共享内存中读取数据
    else {
        printf("Reading from shared memory...\n");

        // 等待条件信号量
        sop.sem_num = 1;
        sop.sem_op = -1;
        sop.sem_flg = SEM_UNDO;
        semop(sem_id, &sop, 1);

        // 从共享内存读取数据
        printf("Data read from shared memory: %s\n", shm_ptr);

        // 发送互斥信号量
        sop.sem_num = 0;
        sop.sem_op = 1;
        sop.sem_flg = SEM_UNDO;
        semop(sem_id, &sop, 1);

        exit(0);
    }

    return 0;
}

```

以上代码中，使用了 `shmget()` 函数创建共享内存，并通过 `shmat()` 函数将该内存段映射到进程的地址空间中。然后，使用 `semget()` 函数创建了一个具有两个信号量的信号量集合，其中一个信号量用于实现互斥，另一个信号量则用于等待条件。

在写进程中，首先等待互斥信号量，然后向共享内存写入数据，并发送条件信号量通知读进程可以开始读取数据。在读进程中，等待条件信号量，然后从共享内存中读取数据，并发送互斥信号量通知写进程可以开始写入数据。

这样，就通过信号量集合和共享内存成功实现了进程间的数据共享和同步。





## 网络编程

****

11

### 网络基础

****

``浏览器``:是客户端的一种

 ``服务器``：服务器是软件和硬件的结合，不算的向客户提供服务

``协议``：两台主机相连，要通信，应该使用粤语，英语，普通话那种通信方式？这种通信方式就叫协议

`端口`：进程要监听端口，操作系统才会把端口的数据给你

<img src="allPic/Macdo2023-04-23 13.30.26.jpg" style="zoom:50%;" />

**调制解调器** 负责模拟电路转和数字电路之间的转换 

![](allPic/Macdo2023-04-23 13.41.08.jpg)

![](allPic/Macdo2023-04-23 13.50.07.jpg)

![](allPic/Macdo2023-04-23 13.52.43.jpg)

![](allPic/Macdo2023-04-23 14.00.39.jpg)

![](allPic/Macdo2023-04-23 14.16.45.jpg)

![](allPic/Macdo2023-04-23 14.44.36.jpg)

![](allPic/Macdo2023-04-24 15.10.10.jpg)

![](allPic/Macdo2023-04-24 15.13.49.jpg)

![](allPic/Macdo2023-04-24 15.16.44.jpg)

![](allPic/Macdo2023-04-24 15.20.11.jpg)

![](allPic/Macdo2023-04-24 15.25.00.jpg)

![](allPic/Macdo2023-04-24 15.47.27.jpg)

目的地址是网卡的地址 源地址也是网卡地址

ether 是物理地址

```
ifconfig

ens160: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.50.8  netmask 255.255.255.0  broadcast 192.168.50.255
        inet6 fe80::20c:29ff:fe6d:de9e  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:6d:de:9e  txqueuelen 1000  (Ethernet)
        RX packets 143560  bytes 24095662 (24.0 MB)
        RX errors 0  dropped 32  overruns 0  frame 0
        TX packets 108138  bytes 18734574 (18.7 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device interrupt 40  memory 0x3fe00000-3fe20000  
```

设置ip地址的时候，会用网卡地址和ip地址绑定

### 关于网络的命令

`sudo ifconfig`

`ping 目标ip`

```
两台计算机之间要ping通 没ping通 无法通行

127.0.0.1 测试网卡是否正常
```

`sudo route`

```
查看路由表
```

`sudo arp -a`

```
查看本arp表
```





### 五类互联网地址

****

五类互联网地址指的是IP地址分类中的五类，每一类的地址范围和用途都有所不同。具体如下：

1. A类IP地址：以0开头的网络号，剩余部分为主机号。其范围是1.0.0.0~126.0.0.0，其中0和127被保留不使用。A类地址通常用于大型企业或组织内部的网络，例如IBM的内部网络就是采用A类地址。
2. B类IP地址：以10开头的网络号，剩余部分为主机号。其范围是128.0.0.0~191.255.0.0。B类地址通常用于中等规模的网络，例如某个城市的医院系统可能会采用B类地址。
3. C类IP地址：以110开头的网络号，剩余部分为主机号。其范围是192.0.0.0~223.255.255.0。C类地址通常用于小型网络，例如家庭或办公网络。
4. D类IP地址：以1110开头的地址，用于多播（Multicast）。它没有主机号，可以表示一个组的地址。D类地址范围是224.0.0.0~239.255.255.255。
5. E类IP地址：以1111开头的地址，用于实验和研究。E类地址范围是240.0.0.0~255.255.255.254。

例如，192.168.1.1是一个C类地址，表示的是一个小型网络中的某台主机；172.16.0.0是一个B类地址，表示的是某个大型企业内部的子网；239.255.255.250是一个D类地址，表示的是某个多播组。





**为什么划分五类互联网地址，那公网Ip呢**

划分五类互联网地址是为了更好地管理和规划IP地址的分配和使用，它们分别是A类、B类、C类、D类和E类。其中，A、B、C三类主要用于公共互联网，而D、E两类则用于特殊目的。

至于公网IP，它是指在公共互联网上可以访问的IP地址，通常指的就是A、B、C三类互联网地址。对于一台连接到公网的计算机或设备来说，必须要有一个公网IP地址才能正常进行网络通信。公网IP地址由各个互联网服务提供商（ISP）负责分配和管理，每个ISP拥有的公网IP地址也是有限的，因此需要进行精细的规划和管理。



**局域网里面的数据如何传输**

局域网IP传送到另外一个局域网，会与255.255.255.0 做或运算 只要前三位然后找arp表,如果有，就把网卡地址天到帧数据的头部，然后目标地址会把地址传输过去



**192.158.50.3/24**

子网演码为前24位都为1，也就是255.255.255.0





### TCP/UDP 的优缺点

****

![](allPic/Macdo2023-04-24 15.56.26.jpg)

![](allPic/Macdo2023-04-24 16.01.09.jpg)

![](allPic/Macdo2023-04-24 16.02.29.jpg)

### TCP的三次握手

****



![](allPic/Macdo2023-04-24 16.05.28.jpg)

![](allPic/Macdo2023-04-24 16.09.33.jpg)

### TCP的编程模型

****

#### 原理

![](allPic/Macdo2023-04-24 16.11.57.jpg)

![](allPic/Macdo2023-04-25 08.59.08.jpg)

![](allPic/Macdo2023-04-25 09.00.47.jpg)

![](allPic/Macdo2023-04-25 09.03.54.jpg)

![](allPic/Macdo2023-04-25 09.05.22.jpg)

![](allPic/Macdo2023-04-25 09.07.36.jpg)

![](allPic/Macdo2023-04-25 09.25.42.jpg)

<img src="allPic/Macdo2023-04-25 09.28.16.jpg" alt="！" style="zoom:50%;" />

<img src="allPic/Macdo2023-04-25 09.28.45.jpg" style="zoom:50%;" />

<img src="allPic/Macdo2023-04-25 09.34.56.jpg" alt="!" style="zoom:50%;" />



<img src="allPic/Macdo2023-04-25 09.36.31.jpg" alt="!" style="zoom:50%;" />

![](allPic/Macdo2023-04-25 09.38.12.jpg)

![](allPic/Macdo2023-04-25 09.39.58.jpg)

<img src="allPic/Macdo2023-04-25 09.41.25.jpg" style="zoom:50%;" />

#### 代码部分

****

**service**

```c
#include <t_stdio.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <arpa/inet.h>      //转换大小段 for htons()
#include <netinet/in.h>    //定义了ipv4的地址结构
#include <ctype.h>          //转换大小写的
#include <unistd.h>



int main(void){

    //创建ipv4的结构
    struct sockaddr_in  struct_ipv4;

    //接收信息
    char buff[128];

    //创建创建一个文件描述符
    //int socket(int domain, int type, int protocol);
    //domain:AF_INET 是IPV4 
    //type: SOCK_STREAM (TCP),SOCK_DGRAM(UDP),SOCK_RAW(原始套接字)
    //protocol: 0 默认的套接字类型
    int s_fd=socket(AF_INET,SOCK_STREAM,0);
    if(s_fd==-1)E_MSG("socket",-1);

    //ipv4地址端口的结构赋予值
    struct_ipv4.sin_family=AF_INET;
    struct_ipv4.sin_port=htons(5566);  //本地的小段模式转换成网络的通用大段模式
    struct_ipv4.sin_addr.s_addr=htonl(INADDR_ANY);//INADDR_ANY 代表本地主机的任意IP地址


    //将s_fd和本地地址端口进行绑定
    //        struct sockaddr {
    //            sa_family_t sa_family;
    //            char        sa_data[14];
    //        }
    // ipv4的结构存放存放ip和端口，需要转换成通用的地址,ipv4的地址类型为 struct sockaddr_in 
    int b=bind(s_fd,(struct sockaddr *)&struct_ipv4,sizeof(struct_ipv4));
    if(b==-1)E_MSG("bind",-1);

    //int listen(int sockfd, int backlog);
    //把fd设置成被动连接,监听客户端连接的到来
    //将客户端到来的连接放入到味觉连接，backlog为未觉连接的指定的长度

    listen(s_fd,5);

    while(1){
        //从s_fd 设备的未觉连接队列中提取一个进行处理，返回一个连接描述符，
        //使用连接描述符和客户端进行通信
        int c_fd=accept(s_fd,NULL,NULL); //两个NULL为客户端结构地址和结构地址的大小，使用NULL为不存储，也可以定义一个结构来接收 用inet——ntop 转换地址
        if(c_fd==-1)E_MSG("appect",-1);
        //到这三次握手已经OK了，可以进行数据传输了
        //从c_fd中读取客户端发送过来的请求信息
        int r=read(c_fd,buff,128);
        int i;
        for(i=0;i<r;i++){
            buff[i]=toupper(buff[i]);
        }

        //将处理结果回送送客户端
        write(c_fd,buff,r);

        //关闭本地连接
        close(c_fd);

    }



    printf("Done....\n");




    return 0;
}
```

**client**

```c
#include <t_stdio.h>
#include <sys/types.h> 
#include <sys/socket.h> 
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h> //for inet_pton 字符串存储到结构里面
#include <string.h>
#include <unistd.h>

int main(void){

    struct sockaddr_in ser_addr;
    const char * ipstr="127.0.0.1";
    char *msg="this is a message....\n";

    char buff[128];

    //int inet_pton(int af, const char *src, void *dst);
    
    //创建文件描述符
    int fd=socket(AF_INET,SOCK_STREAM,0);
    if(fd==-1)E_MSG("socket",-1);

    //服务器的信息
    ser_addr.sin_family=AF_INET; 
    ser_addr.sin_port=htons(5566);

    //字符串地址 放到 service_addr.sin_addr 的结构里面
    inet_pton(AF_INET,"127.0.0.1",&ser_addr.sin_addr);
    

    //使用fd向服务器发起连接
    int c=connect(fd,(struct sockaddr *)&ser_addr,sizeof(ser_addr));
    if(c==-1)E_MSG("connect",-1);

    //到这里 三次握手已经成功

    write(fd,msg,strlen(msg)+1); //没有+'\0' 需要多加一个字符

    //阻塞等待服务器的相应,返回相应的字节
    int r=read(fd,buff,128);
    
    write(1,buff,r);

    close(fd);

    return 0;

}
```







### UDP的编程模型

****

#### 编程模型

![](allPic/Macdo2023-05-02 14.21.06.jpg)

![](allPic/Macdo2023-05-02 14.27.28.jpg)

![](allPic/Macdo2023-05-02 14.28.46.jpg)

![](allPic/Macdo2023-05-02 14.29.32.jpg)

![](allPic/Macdo2023-05-02 14.31.06.jpg)

![](allPic/Macdo2023-05-02 14.32.18.jpg)

![](allPic/Macdo2023-05-02 14.33.09.jpg)



![](allPic/Macdo2023-05-02 15.49.33.jpg)

![](allPic/Macdo2023-05-02 15.51.02.jpg)

#### 需要用到的函数们

```接收数据
 //udp 接收数据
 ssize_t
 recvfrom(int socket, void *restrict buffer, size_t length, int flags,
     struct sockaddr *restrict address, socklen_t *restrict address_len);
     
//发送数据
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);
```

#### 示范代码

**UPD服务端**

```c
#include <t_stdio.h>
#include <netinet/in.h>
#include <unistd.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <arpa/inet.h>

#define BUFFSIZE 1024
char buff[BUFFSIZE];
char IP[40];  //保存客户端的ip


int main(int argc,char *argv[]){
    if(argc <2){
        printf("Usage:%s Port\n",argv[0]);
        exit(EXIT_FAILURE);
    }

    //创建socket 返回该设备的文件描述符
    struct sockaddr_in Serv;  //服务器的socket设备   
    struct sockaddr_in Clie;  //保存客户端的地址
    socklen_t Clie_size;


    int fd=socket(AF_INET,SOCK_DGRAM,0);  //新建文件描述符
    if(fd==-1){
        printf("Udp create Error...\n");
        exit(EXIT_FAILURE);
    }

    Serv.sin_family=AF_INET;
    Serv.sin_port=htons(atoi(argv[1]));
    Serv.sin_addr.s_addr=INADDR_ANY;
    int b=bind(fd,(struct sockaddr *)&Serv,sizeof(Serv));
    if(b==-1){
        perror("bind");return -1;
    }

    while(1){//循环处理
        Clie_size=sizeof(Clie);

        //阻塞等待客户端建立连接，没有客户端，会一直在这等着 Clie 保存客户端信息 //处理完的数据往这个客户端发
        size_t r=recvfrom(fd,buff,(size_t)BUFFSIZE,0,(struct sockaddr *)&Clie,&Clie_size);
        if(r ==-1)break;
        inet_ntop(AF_INET, &Clie.sin_addr,IP,40);  //从客户端的struct的结构里保存up 信息
                             

        printf("Got message From [%s]:%s\n",IP,buff);

        //简单的处理那啥客户端的信息
        for(int i=0;i<r;i++){
            buff[i]=toupper(buff[i]);
        }
       
        //把数据发送回去
        ssize_t s= sendto(fd,buff,r,0,(struct sockaddr *)&Clie,sizeof(Clie));
        if(r ==-1)break;


    }
    close(fd);  //关闭文件描述符

    return 0;
}

```

**UDP客户端**

```c
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>
#include <stdlib.h>


int main(int argc,char *argv[]){
    if(argc !=4){
        printf("Usage:%s Ip Port message\n",argv[0]);
        return -1;
    }



    struct sockaddr_in Ser;

    socklen_t slen=sizeof(Ser);
    Ser.sin_family=AF_INET;
    Ser.sin_port=htons(atoi(argv[2]));
    inet_pton(AF_INET,argv[1],&Ser.sin_addr);

    int fd = socket(AF_INET, SOCK_DGRAM, 0);

    if(fd==-1){
        perror("socket");
        return -1;
    }

    char buff[1024];
    strcpy(buff,argv[3]);

    int s=sendto(fd,buff,strlen(buff)+1,0,(struct sockaddr*)&Ser,slen);
    if(s==-1){
        perror("sendto");
        return -1;
    }

    int r=recvfrom(fd,buff,1024,0,(struct sockaddr *)&Ser,&slen);

    write(1,buff,r);
    printf("\n");

    close(fd);


    

    return 0;
}
```





## 线程



### 线程基本概念

//编译的时候需要指定链接的库 ，加上参数-lpthread

```bash
gcc source.c -lpthread
```

每个线程都有自己的tid 和 TCB 终端进程中线程所有线程的运行状况

```bash
top -H -p 线程id
```

一个进程可以包含多个线程，至少要有一个主线程
进程共享进程的资源（代码段，堆里面的），但是每个线程可以有自己的私有资源
每个线程有自己的执行函数，线程私有资源在函数对应的栈针里面

两个进程之间是不可能通信的，需要借助内核空间
线程之间通信可以
进程之间对资源访问，会异步

#### **线程的创建**
在当前的进程中创建一个新的线程 编译和连接的时候 需要链接phthread

```c

#include <pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                    void *(*start_routine) (void *), void *arg);


参数:
    thread：
        存放新建线程的tid的空间，指向线程标识符的指针，需要在 pthread_create 函数中指定该参数的值，以便在调用其他线程 API 时标识线程。
    attr:
        指定线程的属性，可以为 NULL，表示使用默认属性。如果需要修改属性，需要定义一个 pthread_attr_t 类型的变量，并使用相关 API 设置属性值。
    start_routine:
        指定线程运行的函数地址，该函数需要使用 void* 类型作为参数和返回值。
    arg:
        传递给函数唯一的一个参数，线程运行函数的参数，需要使用 void* 类型传递，如果没有参数可以传入 NULL。
返回值:
    0 or 错误码
注意：编译和连接的时候 需要链接-pthread

```

#### **在线程中打印自己的线程id**

```c
pthread_t pthread_self(void);
功能:
    返回当前线程的tid
返回值：
    这个函数总是成功执行，返回当前线程的id

注意：编译和连接的时候 需要链接-pthread
```

####  **线程分离**
如果线程设置了分离的状态，系统会自动回收线程的资源,主线程不用等待

```c
int pthread_detach(pthread_t thread);
参数:tid
返回值:成功0

//使用 pthread_detach() 函数将线程标记为分离线程，即可实现线程的分离。一旦线程被标记为分离线程，它就无法被加入到另一个线程中，也就无法再被等待和回收资源。另外，分离线程也不能调用 pthread_join() 函数。
```
####  **退出线程**

```c
 #include <pthread.h>
void pthread_exit(void *retval);

//pthread_exit函数是POSIX线程库中的一个函数，用于退出当前线程并返回一个指向void的指针，它有一个参数，用于指定该指针的值。该函数通常用于在线程完成工作后退出线程，以便其他线程可以继续执行。

//在调用pthread_exit函数后，线程将被终止并立即释放它所持有的所有资源，包括栈、线程局部存储和互斥量等。因此，使用pthread_exit函数是一个比较安全的方法来退出线程，而不会导致内存泄漏或其他资源泄漏的问题。
```

#### **线程取消**

```c
#include <pthread.h>

int pthread_cancel(pthread_t thread);
指定的线程id
 // pthread_cancel() 函数用于向指定线程发送取消请求，请求取消指定线程。取消的具体实现方式取决于目标线程是否对取消进行了处理。如果目标线程在等待条件变量等一些其他阻塞操作时，将会被唤醒以响应取消请求。如果目标线程没有对取消进行处理，那么调用 pthread_cancel() 并不会立即结束线程，需要在目标线程中显式地检测取消请求并作出响应。
```

#### **等待线程**

```c
#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);
其中，thread 参数是要等待的线程的 ID；retval 参数是指向线程退出状态的指针，它可以是空指针。


//当一个线程结束时，它会调用 pthread_exit() 函数来退出。如果线程的主函数中有一个返回语句，那么它相当于调用了 pthread_exit() 函数，同时将返回值作为参数传递给了 pthread_exit() 函数。 pthread_join() 函数可以用来获取线程退出时的返回值。如果不关心线程的返回值，可以将 retval 参数设置为 NULL。

//需要注意的是，如果一个线程在等待期间被取消，那么 pthread_join() 函数会返回一个错误码 EINTR。此时，可以重新调用 pthread_join() 函数，或者在信号处理函数中重新设置信号的处理方式来避免这种情况的发生。
```





### 线程同步

****

#### 可重入函数

函数值访问自己栈帧里面的数据就叫**可重入函数**，如果访问了线程的静态变量，数据段的数据和堆空间里的数据就叫做**不可重入函数** 线程函数访问共享资源的时候，是异步的，对共享资源的访问或者修改是不确定的，这样造成程序的运行结果也不一样 所以要引入一个概念，线程1访问资源的时候，线程2不能访问，等线程1访问完，线程2再访问

#### 线程同步
**三种方式mutex锁 条件变量 信号量**



#### mutex锁

任意时刻，只能有一个时刻访问该对象

![](allPic/Macdo2023-05-09 13.29.37.jpg)

![](allPic/Macdo2023-05-09 13.44.24.jpg)

![Macdo2023-05-09 13.45.02](allPic/Macdo2023-05-09 13.45.02.jpg)

![](allPic/Macdo2023-05-09 13.54.28.jpg)

![]()



```c
typedef union
{
  struct __pthread_mutex_s __data;
  char __size[48];
  long int __align;
} pthread_mutex_t;

pthread_mutex_t MyLock=PTHREAD_MUTEX_INITIALIZER;//静态初始化一把锁；

int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr);//第二个参数可以为null
     
int pthread_mutex_destroy (pthread_mutex_t *__mutex)//参数为锁地址
     
  int pthread_mutex_trylock (pthread_mutex_t *__mutex)//尝试上锁，如果没有成功 该干嘛干嘛
    
int pthread_mutex_lock (pthread_mutex_t *__mutex)
   
int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict);
       
int pthread_mutex_unlock (pthread_mutex_t *__mutex);//释放锁空间，放函数的最后
    

```

**示范代码**

```c
#include <stdio.h>
#include <pthread.h>

//定义一个mutex 锁类型的变量
pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER; //初始化的宏

int val=0;	//要修改的全局变量

void * handle(void *arg){ //线程访问函数
	int temp;
	
	for(int i=0;i<50000;i++){
		pthread_mutex_lock(&mutex); //	上锁的区域在临界区域,访问要修改全局变量的时候，才加锁
		temp=val;
		temp++;
		printf("tid:%lu woring,temp=%d\n",pthread_self(),temp);
		val=temp;
		pthread_mutex_unlock(&mutex);//	上锁的区域在临界区域,
	}
	
	return NULL;

}

int main(){
	//初始化锁
	pthread_mutex_init(&mutex,NULL);
	pthread_t tid1,tid2;

	pthread_create(&tid1,NULL,handle,"tid1");
	pthread_create(&tid2,NULL,handle,"tid2");
	pthread_join(tid1,NULL);
	pthread_join(tid2,NULL);
	
	//释放锁空间
	pthread_mutex_destroy(&mutex);

	return 0;
}

```



#### 条件变量

****

![](allPic/Macdo2023-05-11 09.50.10.jpg)



![Macdo2023-05-11 09.51.51](allPic/Macdo2023-05-11 09.51.51.jpg)

![Macdo2023-05-11 10.16.43](allPic/Macdo2023-05-11 10.16.43.jpg)

![Macdo2023-05-11 10.17.47](allPic/Macdo2023-05-11 10.17.47.jpg)

![Macdo2023-05-11 10.18.38](allPic/Macdo2023-05-11 10.18.38.jpg)

![Macdo2023-05-11 10.19.08](allPic/Macdo2023-05-11 10.19.08.jpg)

![Macdo2023-05-11 10.21.53](allPic/Macdo2023-05-11 10.21.53.jpg)

##### 条件变量 示范代码

```c
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

pthread_cond_t cond=PTHREAD_COND_INITIALIZER;
pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;


//节点
typedef struct node{
    int data;
    struct node * next;
}node_t;

//节点指针
typedef node_t * node_p;  //

//节点头部
node_p list=NULL;

void *production(void *arg){
    node_p tmp;
    while(1){
        tmp=(node_t *)malloc(sizeof(node_t));
        tmp->data=rand() % 1000 +1;// Make New Node;
        printf("p:%d make a data\n",tmp->data);

        pthread_mutex_lock(&mutex);
        printf("p:LOCKED.....\n");
    //临界资源start
        tmp->next=list;  // Make New Node;
        list=tmp;
        printf("p:%d add to list\n",list->data);
    //临界资源end

    

        pthread_mutex_unlock(&mutex);
        printf("p:UNLOCKED.....\n");
        pthread_cond_signal(&cond);
        printf("boardcast to anther pthread......\n");
        //sleep(rand()%3+1);

    }
    return NULL;
}
void *consume(void *arg){
    
    while(1){
        pthread_mutex_lock(&mutex);
        while(list==NULL){
            printf("c:Data be Locked .......C: for wait\n");
            
            //解锁并且等待
            //如果其他线程发送了 pthread_cond_signal(&cond); 信号，这个时候条件为真了，并且会加锁执行下面的操作
            
            pthread_cond_wait(&cond,&mutex); //如果没有收到信号那啥解锁等待如果条件为真，会加锁执行下一步
            printf("c:unlocking....\n");
        }
        //TODO: 
        
        node_p tmp=list;
        list=list->next;
        
        printf("c:%d freeing \n",tmp->data);
        sleep(1);

        free(tmp);
        tmp=NULL;
        pthread_mutex_unlock(&mutex);
        //sleep(rand()%3+1);

        



    }
    return NULL;
}




int main(){
    srand(time(NULL));
    printf("hello,kitty\n");
    pthread_t tid1,tid2;
    pthread_create(&tid1,NULL,production,NULL);
    pthread_create(&tid2,NULL,consume,NULL);

    pthread_join(tid1,NULL);
    pthread_join(tid2,NULL);

    return 0;
}



#if 0
int main(){
    pthread_cond_init();
    pthread_cond_signal(&cond);//发送信号告知等待的线程/，条件为真了
    pthread_cond_wait(&cond,&mute);//阻塞 解锁等待,当有信号了，再重新获取锁，并且加锁

}


#endif 
```

##### 条件变量 GPT

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;   // 定义互斥锁
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;     // 定义条件变量
int num = 0;

void *thread1(void *arg)
{
    printf("thread1: lock the mutex\n");
    pthread_mutex_lock(&mutex);  //上锁
    while (num == 0)
    {
        printf("thread1: wait for the condition\n");
        pthread_cond_wait(&cond, &mutex);  // 解锁并且等待条件变量，如果收到条件变量，线程会加锁执行下一步操作
    }
    printf("thread1: the condition has been changed\n");
    printf("thread1: num = %d\n", num);
    pthread_mutex_unlock(&mutex);
    printf("thread1: unlock the mutex\n");
    pthread_exit(NULL);
}

void *thread2(void *arg)
{
    printf("thread2: lock the mutex\n");
    pthread_mutex_lock(&mutex);
    printf("thread2: change the condition\n");
    num = 1;
    pthread_cond_signal(&cond);             // 发送条件变量  先发送条件变量，再解锁
    printf("thread2: unlock the mutex\n");
    pthread_mutex_unlock(&mutex);
    pthread_exit(NULL);
}

int main()
{
    pthread_t tid1, tid2;
    if (pthread_create(&tid1, NULL, thread1, NULL) != 0)
    {
        printf("create thread1 error\n");
        return 1;
    }
    
    if (pthread_create(&tid2, NULL, thread2, NULL) != 0)
    {
        printf("create thread2 error\n");
        return 2;
    }

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    return 0;
}

```



#### 信号量

****

次线程没有接收到信号的时候，就阻塞等待，如果其他线程发送了信号，就开始执行线程里面的内容



```c
#include <semaphore.h>  //头文件 编译的时候链接一下线程 -lpthread
sem_t p；	//定义一个信号量
sem_init(&p,0,7);   //可以消费的数量为7,初始化就可以消费7个  
sem_wait(&p); 可以执行7次，因为初始化值为7，每执行一次，信号量剪掉1，如果信号量为0 会阻塞等待信号
sem_post(&p);	p的信号量加1 sem_wait(&p)可以执行了
```

![](allPic/Macdo2023-05-16 13.07.08.jpg)

![Macdo2023-05-16 13.10.48](allPic/Macdo2023-05-16 13.10.48.jpg)

![Macdo2023-05-16 13.12.10](allPic/Macdo2023-05-16 13.12.10.jpg)

![Macdo2023-05-16 13.12.52](allPic/Macdo2023-05-16 13.12.52.jpg)

![Macdo2023-05-16 13.13.54](allPic/Macdo2023-05-16 13.13.54.jpg)

![Macdo2023-05-16 13.15.23](allPic/Macdo2023-05-16 13.15.23.jpg)

#### 函数们

**sem_init**

~~~c
`sem_init` 是一个函数，用于初始化一个信号量（semaphore）对象。它的原型如下：

```c
int sem_init(sem_t *sem, int pshared, unsigned int value);
```

函数参数的含义如下：

- `sem`：指向要初始化的信号量对象的指针。
- `pshared`：指定信号量的共享方式，可选值为0或非0。
  - 若为0，表示信号量在进程内的线程之间共享。
  - 若非0，表示信号量在多个进程之间共享，此时需要使用具名信号量（named semaphore）。
- `value`：指定信号量的初始值。

成功初始化信号量后，`sem` 就可以用于后续的信号量操作，比如等待信号量和发送信号量。

需要注意的是，`sem_init` 函数在使用前需要保证 `sem` 指向的内存空间已经分配，并且需要适当的权限以执行该函数。初始化的信号量在使用完后应该使用 `sem_destroy` 函数进行清理。

如果初始值为正数，表示可用资源的数量。在每次成功执行 sem_wait 操作时，信号量的值会递减，表示使用了一个资源。而在执行 sem_post 操作时，信号量的值会递增，表示释放了一个资源。初始值为正数时，表示初始可用的资源数量。
如果初始值为0，表示没有可用的资源。在执行 sem_wait 操作时，如果信号量的值为0，则线程会被阻塞，直到有其他线程执行 sem_post 操作释放资源并使信号量的值大于0。
如果初始值为负数，表示信号量的值与等待线程的数量有关。在实际使用中，一般不会将初始值设置为负数。
~~~



##### 示范代码

```c
/**
 * 信号量
 */
#include<pthread.h>
#include <t_stdio.h>
#include <unistd.h>
#include <time.h>
#include <semaphore.h>
#include <stdlib.h>



#define SIZE 7

//定义一个指针类型 相当于把 int[size] 这种类型重新命名为 que_t
typedef int que_t[SIZE]; 

que_t que; //定义队列 相当于 int que[size];

sem_t p,c; //定义信号量，类型的变量，分别用于生产者(可以)和消费者，

void show(const char *who){
    printf("%s:[ ",who);
    for(int i=0;i<SIZE;i++)
        printf("%d\t",que[i]);
    //printf(" [p: %lld ],[c: %lld ]",p.__align,c.__align);
    printf("]\n");
}


void *product(void * arg){
    int index=0; int value;
    while(1){
        sleep(rand()%3+1);
        sem_wait(&p);               //如果p的值等于0阻塞，如果不等于0;减去1
        
        value=rand()%500;      //假装生产赋值
        que[index]=value;      //假装生产赋值
        show("p");
        printf("P:index =%d,value=%d\n",index,value);
        index= (index+1) % SIZE;    //更新索引
        sem_post(&c);               //给可以消费的数量加1
    }
    return NULL;
}

void *consume(void * arg){
    int index=0;
    int tmp;  //消费的tmp
    while(1){
        show("c");
        sem_wait(&c);           //如果c的值等于0，阻塞等待，如果不等于0,减去1 
        show("c2");
        tmp=que[index]; //得到值
        que[index]=-1;  //把消费过的值置为-1; 说明消费过
        index=(index+1) %7;
       
        printf("c:index =%d,value=%d\n",index,tmp);
        sem_post(&p);  //可以生产的数量+1  
        //sleep(rand() %3 +1);    
    }
    return NULL;
}

int main(){

    //初始化信号量
    sem_init(&p,0,7);   //可以消费的数量为7,初始化就可以消费7个
    sem_init(&c,0,0); //消费的数量默认设置为0 如果没有post C 说明sem_wait 一直阻塞等待

    srand(time(NULL));
    pthread_t pid,cid;

    pthread_create(&pid,NULL,product,NULL);
    pthread_create(&cid,NULL,consume,NULL);
    

    pthread_join(pid,NULL);
    pthread_join(cid,NULL);
    
    sem_destroy(&p);
    sem_destroy(&c);
    return 0;
}
```





##### 示范代码gpt

****

编译加上 -lpthread

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

#define ARRAY_SIZE 10
#define NUM_THREADS 3

int global_array[ARRAY_SIZE];
sem_t semaphore;

void* thread_function(void* arg) {
    int thread_id = *(int*)arg;
    int i;

    for (i = 0; i < ARRAY_SIZE; i++) {
        // 等待信号量
        sem_wait(&semaphore);

        // 修改全局数组
        global_array[i] = thread_id;

        // 发送信号量
        sem_post(&semaphore);
    }

    pthread_exit(NULL);
}

int main() {
    pthread_t threads[NUM_THREADS];
    int thread_ids[NUM_THREADS];
    int i;

    // 初始化信号量
    sem_init(&semaphore, 0, 1);

    // 创建多个线程
    for (i = 0; i < NUM_THREADS; i++) {
        thread_ids[i] = i;
        pthread_create(&threads[i], NULL, thread_function, &thread_ids[i]);
    }

    // 等待线程结束
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // 打印全局数组的值
    for (i = 0; i < ARRAY_SIZE; i++) {
        printf("%d ", global_array[i]);
    }
    printf("\n");

    // 销毁信号量
    sem_destroy(&semaphore);

    return 0;
}

```


