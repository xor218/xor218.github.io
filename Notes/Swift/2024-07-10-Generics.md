---
layout: post
author: "大西瓜"
title: "Generics 泛型"
date:   2024-07-10 21:27:29 +0800
categories: [update,Swift] 
---





## 泛形

**编写适用于多种类型的代码并指定这些类型的要求。**

通用代码使您能够编写灵活的、可重用的函数和类型，这些函数和类型可以根据您定义的要求与任何类型一起使用。您可以编写避免重复并以清晰、抽象的方式表达其意图的代码。

泛型是 Swift 最强大的功能之一，Swift 标准库的大部分都是用泛型代码构建的。事实上，您在整个语言指南中一直在使用泛型，即使您没有意识到这一点。例如，Swift 的 `Array` 和 `Dictionary` 类型都是泛型集合。您可以创建一个保存 `Int` 值的数组，或者一个保存 `String` 值的数组，或者实际上是可以在 Swift 中创建的任何其他类型的数组。同样，您可以创建一个字典来存储任何指定类型的值，并且该类型没有限制。





### 1.泛型解决的问题 the problem that generics solov

这是一个名为 `swapTwoInts(_:_:)` 的标准非泛型函数，它交换两个 `Int` 值：

```swift

func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

此函数使用输入输出参数来交换 `a` 和 `b` 的值，如输入输出参数中所述。

`swapTwoInts(_:_:)` 函数将 `b` 的原始值交换为 `a` ，将 `a` 的原始值交换为 `b` 。您可以调用此函数来交换两个 `Int` 变量中的值：

```swift
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// Prints "someInt is now 107, and anotherInt is now 3"
```

`swapTwoInts(_:_:)` 函数很有用，但它只能与 `Int` 值一起使用。如果要交换两个 `String` 值或两个 `Double` 值，则必须编写更多函数，例如 `swapTwoStrings(_:_:)` 和 `swapTwoDoubles(_:_:)` 功能如下图：

```swift
func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}


func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

您可能已经注意到 `swapTwoInts(_:_:)` 、 `swapTwoStrings(_:_:)` 和 `swapTwoDoubles(_:_:)` 函数的主体是相同的。唯一的区别是它们接受的值的类型（ `Int` 、 `String` 和 `Double` ）。

编写一个交换任意类型的两个值的函数更有用，也更灵活。通用代码使您能够编写这样的函数。 （这些函数的通用版本定义如下。）

> **Note**:
>
> 在所有三个函数中， `a` 和 `b` 的类型必须相同。如果 `a` 和 `b` 不是同一类型，则无法交换它们的值。 Swift 是一种类型安全语言，不允许（例如） `String` 类型的变量和 `Double` 类型的变量相互交换值。尝试这样做会导致编译时错误。



### 2.通用类型

泛型函数可以用于任何类型。这是上面的 `swapTwoInts(_:_:)` 函数的通用版本，称为 `swapTwoValues(_:_:)` ：

```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

`swapTwoValues(_:_:)` 函数的主体与 `swapTwoInts(_:_:)` 函数的主体相同。但是， `swapTwoValues(_:_:)` 的第一行与 `swapTwoInts(_:_:)` 略有不同。以下是第一行的比较：

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int)
func swapTwoValues<T>(_ a: inout T, _ b: inout T)
```

该函数的通用版本使用占位符类型名称（在本例中称为 `T` ）而不是实际类型名称（例如 `Int` 、 `String` 、或 `Double` ）。占位符类型名称没有说明 `T` 必须是什么，但它确实表明 `a` 和 `b` 必须属于同一类型 `T` ，无论 `T` 代表什么。每次调用 `swapTwoValues(_:_:)` 函数时都会确定用于代替 `T` 的实际类型。

泛型函数和非泛型函数之间的另一个区别是泛型函数的名称 ( `swapTwoValues(_:_:)` ) 后跟尖括号 ( `<T>` ) /b2> ）。括号告诉 Swift `T` 是 `swapTwoValues(_:_:)` 函数定义中的占位符类型名称。因为 `T` 是一个占位符，Swift 不会查找名为 `T` 的实际类型。

`swapTwoValues(_:_:)` 函数现在可以按照与 `swapTwoInts` 相同的方式调用，不同之处在于它可以传递任何类型的两个值，只要这两个值的类型相同彼此一样。每次调用 `swapTwoValues(_:_:)` 时，都会根据传递给函数的值类型推断出 `T` 使用的类型。



在下面的两个示例中， `T` 分别被推断为 `Int` 和 `String` ：

```swift
var someInt = 3
var anotherInt = 107
swapTwoValues(&someInt, &anotherInt)
// someInt is now 107, and anotherInt is now 3


var someString = "hello"
var anotherString = "world"
swapTwoValues(&someString, &anotherString)
// someString is now "world", and anotherString is now "hello"
```



> **Note**:上面定义的 `swapTwoValues(_:_:)` 函数受到名为 `swap` 的通用函数的启发，该函数是 Swift 标准库的一部分，并且会自动供您在应用程序中使用。如果您需要在自己的代码中实现 `swapTwoValues(_:_:)`函数的行为，则可以使用 Swift 现有的 `swap(_:_:)` 函数，而不是提供自己的实现。





### 3.类型参数

在上面的 `swapTwoValues(_:_:)` 示例中，占位符类型 `T` 是类型参数的示例。类型参数指定并命名占位符类型，并紧跟在函数名称之后，位于一对匹配的尖括号之间（例如 `<T>` ）。



指定类型参数后，您可以使用它来定义函数参数的类型（例如 `swapTwoValues(_:_:)` 函数的 `a` 和 `b` 参数） ，或作为函数的返回类型，或作为函数体内的类型注释。在每种情况下，每当调用函数时，类型参数都会替换为实际类型。 （在上面的 `swapTwoValues(_:_:)` 示例中， `T` 在第一次调用函数时被替换为 `Int` ，并在第一次调用时被替换为 `String` 第二次被调用。）

您可以通过在尖括号内写入多个类型参数名称（以逗号分隔）来提供多个类型参数。





### 4.命名类型参数

在大多数情况下，类型参数具有描述性名称，例如 `Dictionary<Key, Value>` 中的 `Key` 和 `Value` 以及 `Array<Element>` > ，它告诉读者类型参数和它所使用的泛型类型或函数之间的关系。但是，当它们之间没有有意义的关系时，传统上使用单个字母来命名它们，例如 `T` 和 `V` ，例如上面 `swapTwoValues(_:_:)` 函数中的 `T` 。

>
>
>**Note**:始终为类型参数提供大驼峰式名称（例如 `T` 和 `MyTypeParameter` ），以表明它们是类型的占位符，而不是值。



### 5.通用类型Generic Type

除了泛型函数之外，Swift 还允许您定义自己的泛型类型。这些是自定义类、结构和枚举，可以与任何类型一起使用，类似于 `Array` 和 `Dictionary` 。

本节向您展示如何编写名为 `Stack` 的通用集合类型。堆栈是一组有序的值，类似于数组，但其操作集比 Swift 的 `Array` 类型更受限制。数组允许在数组中的任何位置插入和删除新项目。然而，堆栈只允许将新项目附加到集合的末尾（称为将新值推入堆栈）。类似地，堆栈允许仅从集合末尾删除项目（称为从堆栈中弹出值）。

> **Note**:`UINavigationController` 类使用堆栈的概念来建模其导航层次结构中的视图控制器。您调用 `UINavigationController` 类 `pushViewController(_:animated:)` 方法将视图控制器添加（或推送）到导航堆栈，并调用其 `popViewControllerAnimated(_:)` 方法删除（或弹出）导航堆栈中的视图控制器。当您需要严格的“后进先出”方法来管理集合时，堆栈是一个有用的集合模型。



下图显示了堆栈的压入和弹出行为：

<img src="https://docs.swift.org/swift-book/images/org.swift.tspl/stackPushPop@2x.png">

- 当前堆栈上有三个值。
- 第四个值被推入堆栈顶部。
- 堆栈现在包含四个值，最新的值位于顶部。
- 堆栈顶部的项目被弹出。
- 弹出一个值后，堆栈再次保存三个值。

```swift
struct IntStack {
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
}
```

此结构使用名为 `items` 的 `Array` 属性来存储堆栈中的值。 `Stack` 提供了两种方法： `push` 和 `pop` ，用于将值压入堆栈或从堆栈中弹出。这些方法被标记为 `mutating` ，因为它们需要修改（或变异）结构体的 `items`数组。

但是，上面显示的 `IntStack` 类型只能与 `Int` 值一起使用。定义一个通用的 `Stack` 结构会更有用，它可以管理任何类型值的堆栈。

这是相同代码的通用版本：

```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
}
```

请注意 `Stack` 的泛型版本本质上与非泛型版本相同，但具有名为 `Element` 的类型参数，而不是 `Int` 的实际类型。此类型参数写在结构名称后面的一对尖括号 ( `<Element>` ) 内。

`Element` 为稍后提供的类型定义占位符名称。这种未来类型可以在结构定义中的任何位置称为 `Element` 。在本例中， `Element` 在三个地方用作占位符：

- 创建一个名为 `items` 的属性，该属性使用 `Element` 类型值的空数组进行初始化
- 指定 `push(_:)` 方法有一个名为 `item` 的参数，该参数的类型必须为 `Element`
- 指定 `pop()` 方法返回的值将是 `Element` 类型的值

因为它是泛型类型，所以 `Stack` 可用于在 Swift 中创建任何有效类型的堆栈，其方式与 `Array` 和 `Dictionary` 类似。

您可以通过在尖括号内写入要存储在堆栈中的类型来创建一个新的 `Stack` 实例。例如，要创建新的字符串堆栈，请编写 `Stack<String>()` ：

```swift
var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// the stack now contains 4 strings

```

以下是将这四个值推入堆栈后 `stackOfStrings` 的外观：

<img src="https://docs.swift.org/swift-book/images/org.swift.tspl/stackPushedFourStrings@2x.png">

从堆栈中弹出一个值会删除并返回顶部值 `"cuatro"` ：

```swift
let fromTheTop = stackOfStrings.pop()
// fromTheTop is equal to "cuatro", and the stack now contains 3 strings
```

以下是弹出顶部值后堆栈的外观：

<img src="https://docs.swift.org/swift-book/images/org.swift.tspl/stackPoppedOneString@2x.png">





### 6.扩展泛型

**扩展（extension）是用于向现有的类、结构体、枚举和协议添加新功能的机制。扩展是编译时行为，意味着它们在编译时被合并到原始类型中，因此可以无缝地使用扩展中定义的方法、属性和其他成员。**

当您扩展泛型类型时，您不会提供类型参数列表作为扩展定义的一部分。相反，原始类型定义中的类型参数列表在扩展主体中可用，并且原始类型参数名称用于引用原始定义中的类型参数。

以下示例扩展通用 `Stack` 类型以添加名为 `topItem` 的只读计算属性，该属性返回堆栈顶部的项目，而不将其从堆栈中弹出：

```swift
extension Stack {
    var topItem: Element? {  //扩展里面也可以直接用占位符
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
```

`topItem` 属性返回 `Element` 类型的可选值。如果堆栈为空，则 `topItem` 返回 `nil` ；如果堆栈不为空，则 `topItem` 返回 `items` 数组中的最后一项。

请注意，此扩展没有定义类型参数列表。相反，在扩展中使用 `Stack` 类型的现有类型参数名称 `Element` 来指示 `topItem` 计算属性的可选类型。

`topItem` 计算属性现在可以与任何 `Stack` 实例一起使用，以访问和查询其顶部项目，而无需删除它。

```swift
if let topItem = stackOfStrings.topItem {
    print("The top item on the stack is \(topItem).")
}
// Prints "The top item on the stack is tres."
```

泛型类型的扩展还可以包括扩展类型的实例必须满足才能获得新功能的要求，如下面的带有泛型Where子句的扩展中所述。





### 7. 类型约束

`swapTwoValues(_:_:)` 函数和 `Stack` 类型可以与任何类型一起使用。但是，有时对可与泛型函数和泛型类型一起使用的类型强制执行某些类型约束很有用。类型约束指定类型参数必须从特定类继承，或者符合特定协议或协议组合。

例如，Swift 的 `Dictionary` 类型对可用作字典键的类型进行了限制。如字典中所述，字典键的类型必须是可散列的。也就是说，它必须提供一种使自己具有独特代表性的方法。 `Dictionary` 需要其键是可散列的，以便它可以检查它是否已包含特定键的值。如果没有此要求， `Dictionary` 无法判断是否应该插入或替换特定键的值，也无法找到字典中已有的给定键的值。

此要求是通过对 `Dictionary` 的键类型进行类型约束来强制执行的，该约束指定键类型必须符合 `Hashable`协议，这是 Swift 标准库中定义的特殊协议。默认情况下，所有 Swift 的基本类型（例如 `String` 、 `Int` 、 `Double` 和 `Bool` ）都是可哈希的。有关使您自己的自定义类型符合 `Hashable` 协议的信息，请参阅符合 Hashable 协议。

您可以在创建自定义泛型类型时定义自己的类型约束，这些约束提供了泛型编程的大部分功能。像 `Hashable`这样的抽象概念根据其概念特征而不是具体类型来表征类型。



### 8.类型约束语法

您可以通过在类型参数名称后面放置单个类或协议约束来编写类型约束，并用冒号分隔，作为类型参数列表的一部分。泛型函数类型约束的基本语法如下所示（尽管泛型类型的语法相同）：



```swift
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
    // function body goes here
}
```

上面的假设函数有两个类型参数。第一个类型参数 `T` 具有类型约束，要求 `T` 是 `SomeClass` 的子类。第二个类型参数 `U` 具有类型约束，要求 `U` 符合协议 `SomeProtocol` 



**Chagpt**

----

好的，以下是一个完整的示例代码，展示如何定义和使用一个带有泛型参数的函数，该函数要求泛型参数分别符合某个类和某个协议。

**示例代码**

首先，定义一个类 `SomeClass` 和一个协议 `SomeProtocol`：

```swift
class SomeClass {
    var value: Int

    init(value: Int) {
        self.value = value
    }

    func describe() -> String {
        return "SomeClass with value \(value)"
    }
}

protocol SomeProtocol {
    func protocolMethod() -> String
}
```

然后，定义一个符合 `SomeProtocol` 协议的类 `AnotherClass`：

```swift
class AnotherClass: SomeProtocol {
    var name: String

    init(name: String) {
        self.name = name
    }

    func protocolMethod() -> String {
        return "AnotherClass with name \(name)"
    }
}
```

现在，定义一个带有泛型参数的函数 `someFunction`，这些泛型参数分别符合 `SomeClass` 和 `SomeProtocol`：

```swift
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
    print(someT.describe())
    print(someU.protocolMethod())
}
```

最后，使用 `someFunction` 函数：

```swift
let instanceOfSomeClass = SomeClass(value: 42)
let instanceOfAnotherClass = AnotherClass(name: "Example")

someFunction(someT: instanceOfSomeClass, someU: instanceOfAnotherClass)
```

**解释**

1. **定义类和协议**：
   - `SomeClass` 是一个具有 `value` 属性和 `describe` 方法的类。
   - `SomeProtocol` 是一个协议，要求实现 `protocolMethod` 方法。

2. **符合协议的类**：
   - `AnotherClass` 是一个符合 `SomeProtocol` 协议的类，具有 `name` 属性和 `protocolMethod` 方法的实现。

3. **带有泛型参数的函数**：
   - `someFunction` 函数带有两个泛型参数 `T` 和 `U`，分别要求 `T` 符合 `SomeClass` 和 `U` 符合 `SomeProtocol`。
   - 函数体中调用了 `someT` 的 `describe` 方法和 `someU` 的 `protocolMethod` 方法。

4. **使用函数**：
   - 创建 `SomeClass` 和 `AnotherClass` 的实例。
   - 调用 `someFunction` 函数，传入这两个实例。

**代码输出**

运行上述代码会输出：

```
SomeClass with value 42
AnotherClass with name Example
```

这个示例展示了如何定义和使用一个带有泛型参数的函数，这些泛型参数分别符合某个类和某个协议。如果你有更多问题或需要进一步解释，请随时告诉我！





### 9. 泛型类型约束

这是一个名为 `findIndex(ofString:in:)` 的非泛型函数，它被赋予一个要查找的 `String` 值以及一个要在其中查找它的 `String` 值数组。 `findIndex(ofString:in:)` 函数返回一个可选的 `Int` 值，如果找到，该值将是数组中第一个匹配字符串的索引，如果字符串可以，则返回 `nil` 找不到：

```swift
func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

`findIndex(ofString:in:)` 函数可用于在字符串数组中查找字符串值：

```swift
let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findIndex(ofString: "llama", in: strings) {
    print("The index of llama is \(foundIndex)")
}
// Prints "The index of llama is 2"
```

然而，在数组中查找值的索引的原理不仅仅适用于字符串。您可以通过将任何提及的字符串替换为某种类型 `T`的值来编写与泛型函数相同的功能。



以下是您可能期望的 `findIndex(ofString:in:)` 通用版本（称为 `findIndex(of:in:)` ）的编写方式。请注意，此函数的返回类型仍然是 `Int?` ，因为该函数返回一个可选的索引号，而不是数组中的可选值。但请注意，该函数无法编译，原因在示例后解释：

```swift
func findIndex<T>(of valueToFind: T, in array:[T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind { //需要服从Equatable 才可以使用 == 
            return index
        }
    }
    return nil
}
```

这个函数不能像上面写的那样编译。问题在于相等性检查“ `if value == valueToFind` ”。并非 Swift 中的所有类型都可以与等于运算符 ( `==` ) 进行比较。例如，如果您创建自己的类或结构来表示复杂的数据模型，那么 Swift 无法为您猜测该类或结构的“等于”含义。因此，无法保证此代码适用于每种可能的类型 `T` ，并且当您尝试编译该代码时会报告相应的错误。

然而，一切并没有失去。 Swift 标准库定义了一个名为 `Equatable` 的协议，它要求任何符合的类型实现等于运算符 ( `==` ) 和不等于运算符 ( `!=` ) 比较该类型的任意两个值。所有 Swift 的标准类型都自动支持 `Equatable`协议。

```swift
func findIndex<T: Equatable>(of valueToFind: T, in array:[T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

`findIndex(of:in:)` 的单一类型参数写为 `T: Equatable` ，这意味着“符合 `Equatable` 协议的任何类型 `T` ”。

`findIndex(of:in:)` 函数现在可以成功编译，并且可以与 `Equatable` 的任何类型一起使用，例如 `Double` 或 `String` ：



<div class="mermaid">

classDiagram

  Class01 <|-- AveryLongClass : Cool

  Class03 *-- Class04

  Class05 o-- Class06

  Class07 .. Class08

  Class09 --> C2 : Where am i?

  Class09 --* C3

  Class09 --|> Class07

  Class07 : equals()

  Class07 : Object[] elementData

  Class01 : size()

  Class01 : int chimp

  Class01 : int gorilla

  Class08 <--> C2: Cool label

</div>
